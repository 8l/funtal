f_expression_eof: FOLD LPAREN MU A_IDENTIFIER DOT A_IDENTIFIER RPAREN UNPACK 
##
## Ends in an error in state: 278.
##
## f_expression -> FOLD LPAREN f_mu_type RPAREN . f_expression [ RPAREN RBRACE RANGLE EOF COMMA ]
##
## The known suffix of the stack is as follows:
## FOLD LPAREN f_mu_type RPAREN 
##

Parsing a fold expression of the form "fold <mu-type> <expr>", we have
parsed "fold <type>" and now expect an expression.

f_expression_eof: FOLD LPAREN MU A_IDENTIFIER DOT A_IDENTIFIER Z_IDENTIFIER 
##
## Ends in an error in state: 277.
##
## f_expression -> FOLD LPAREN f_mu_type . RPAREN f_expression [ RPAREN RBRACE RANGLE EOF COMMA ]
##
## The known suffix of the stack is as follows:
## FOLD LPAREN f_mu_type 
##

Parsing a fold expression of the form "fold <mu-type> <expr>", we have
parsed "fold (<mu-type>" and now expect a closing parenthesis.

f_expression_eof: FOLD LPAREN Z_IDENTIFIER 
##
## Ends in an error in state: 276.
##
## f_expression -> FOLD LPAREN . f_mu_type RPAREN f_expression [ RPAREN RBRACE RANGLE EOF COMMA ]
##
## The known suffix of the stack is as follows:
## FOLD LPAREN 
##

Parsing a fold expression of the form "fold <mu-type> <expr>", we have
parsed "fold (" and now expect a recursive type, for example
"mu a . (a,int)->int".

f_expression_eof: FOLD MU A_IDENTIFIER DOT A_IDENTIFIER UNPACK 
##
## Ends in an error in state: 292.
##
## f_expression -> FOLD f_mu_type . f_expression [ RPAREN RBRACE RANGLE EOF COMMA ]
##
## The known suffix of the stack is as follows:
## FOLD f_mu_type 
##

Parsing a fold expression of the form "fold <mu-type> <expr>", we have
parsed "fold <mu-type>" and now expect an expression.

f_expression_eof: FOLD MU UNPACK 
##
## Ends in an error in state: 198.
##
## f_mu_type -> MU . f_type_variable DOT f_type [ Z_IDENTIFIER UNFOLD TF RPAREN RANGLE PI OTHER_IDENTIFIER MINUS LPAREN LANGLE LAMBDA INTEGER IF0 FT FOLD E_IDENTIFIER COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## MU 
##

Parsing a recursive type "mu <variable> . <type>", we have parsed "mu"
and now expect a type variable, for example "a".

f_expression_eof: FOLD MU Z_IDENTIFIER DOT UNPACK 
##
## Ends in an error in state: 201.
##
## f_mu_type -> MU f_type_variable DOT . f_type [ Z_IDENTIFIER UNFOLD TF RPAREN RANGLE PI OTHER_IDENTIFIER MINUS LPAREN LANGLE LAMBDA INTEGER IF0 FT FOLD E_IDENTIFIER COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## MU f_type_variable DOT 
##

Parsing a recursive type "mu <variable> . <type>", we have parsed
"mu <variable> ."  and now expect a type, for example "(int) -> int".

f_expression_eof: FOLD MU Z_IDENTIFIER Z_IDENTIFIER 
##
## Ends in an error in state: 200.
##
## f_mu_type -> MU f_type_variable . DOT f_type [ Z_IDENTIFIER UNFOLD TF RPAREN RANGLE PI OTHER_IDENTIFIER MINUS LPAREN LANGLE LAMBDA INTEGER IF0 FT FOLD E_IDENTIFIER COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## MU f_type_variable 
##

Parsing a recursive type "mu <variable> . <type>", we have parsed
"mu <variable>" and now expect a dot ".".

f_expression_eof: FOLD Z_IDENTIFIER 
##
## Ends in an error in state: 275.
##
## f_expression -> FOLD . f_mu_type f_expression [ RPAREN RBRACE RANGLE EOF COMMA ]
## f_expression -> FOLD . LPAREN f_mu_type RPAREN f_expression [ RPAREN RBRACE RANGLE EOF COMMA ]
##
## The known suffix of the stack is as follows:
## FOLD 
##

Parsing a fold expression, we have parsed the "fold" keyword and now
expect a recursive type "mu <variable> . <type>", for example
"mu a . (a, int) -> int".

f_expression_eof: FT LBRACKET LANGLE UNPACK 
##
## Ends in an error in state: 203.
##
## tuple(f_type) -> LANGLE . loption(separated_nonempty_list(COMMA,f_type)) RANGLE [ Z_IDENTIFIER UNFOLD TF RPAREN RANGLE PI OTHER_IDENTIFIER MINUS LPAREN LANGLE LAMBDA INTEGER IF0 FT FOLD E_IDENTIFIER COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## LANGLE 
##

We expect a tuple type, for example "<int, a, unit, (int)->int>".

f_expression_eof: FT LBRACKET LANGLE Z_IDENTIFIER RPAREN 
##
## Ends in an error in state: 207.
##
## tuple(f_type) -> LANGLE loption(separated_nonempty_list(COMMA,f_type)) . RANGLE [ Z_IDENTIFIER UNFOLD TF RPAREN RANGLE PI OTHER_IDENTIFIER MINUS LPAREN LANGLE LAMBDA INTEGER IF0 FT FOLD E_IDENTIFIER COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## LANGLE loption(separated_nonempty_list(COMMA,f_type)) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 210, spurious reduction of production separated_nonempty_list(COMMA,f_type) -> f_type 
## In state 206, spurious reduction of production loption(separated_nonempty_list(COMMA,f_type)) -> separated_nonempty_list(COMMA,f_type) 
##

We expect a tuple type, for example "<int, a, unit, (int)->int>".

f_expression_eof: FT LBRACKET LPAREN RPAREN ARROW UNPACK 
##
## Ends in an error in state: 224.
##
## f_type -> LPAREN loption(separated_nonempty_list(COMMA,f_type)) RPAREN ARROW . f_type [ Z_IDENTIFIER UNFOLD TF RPAREN RANGLE PI OTHER_IDENTIFIER MINUS LPAREN LANGLE LAMBDA INTEGER IF0 FT FOLD E_IDENTIFIER COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## LPAREN loption(separated_nonempty_list(COMMA,f_type)) RPAREN ARROW 
##

Parsing a function type "(<type>, <type>...) -> <type>", we have parsed
"(<type>, "type>...) ->" and now expect a type.

f_expression_eof: FT LBRACKET LPAREN RPAREN LBRACKET Z_IDENTIFIER 
##
## Ends in an error in state: 216.
##
## f_type -> LPAREN loption(separated_nonempty_list(COMMA,f_type)) RPAREN LBRACKET . stack_prefix RBRACKET ARROW LBRACKET stack_prefix RBRACKET f_type [ Z_IDENTIFIER UNFOLD TF RPAREN RANGLE PI OTHER_IDENTIFIER MINUS LPAREN LANGLE LAMBDA INTEGER IF0 FT FOLD E_IDENTIFIER COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## LPAREN loption(separated_nonempty_list(COMMA,f_type)) RPAREN LBRACKET 
##

Parsing a stack-modifying function type
"(<type>, <type>...) [<stack-prefix>]->[<stack-prefix>] <type>", we
have parsed "(<type>, <type>...) [" and now expect a stack prefix, for
example "::" or "int::unit::".

f_expression_eof: FT LBRACKET LPAREN RPAREN Z_IDENTIFIER 
##
## Ends in an error in state: 215.
##
## f_type -> LPAREN loption(separated_nonempty_list(COMMA,f_type)) RPAREN . ARROW f_type [ Z_IDENTIFIER UNFOLD TF RPAREN RANGLE PI OTHER_IDENTIFIER MINUS LPAREN LANGLE LAMBDA INTEGER IF0 FT FOLD E_IDENTIFIER COMMA A_IDENTIFIER ]
## f_type -> LPAREN loption(separated_nonempty_list(COMMA,f_type)) RPAREN . LBRACKET stack_prefix RBRACKET ARROW LBRACKET stack_prefix RBRACKET f_type [ Z_IDENTIFIER UNFOLD TF RPAREN RANGLE PI OTHER_IDENTIFIER MINUS LPAREN LANGLE LAMBDA INTEGER IF0 FT FOLD E_IDENTIFIER COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## LPAREN loption(separated_nonempty_list(COMMA,f_type)) RPAREN 
##

Parsing a function type, we have parsed "(<type>, <type>...)" so far. We
expect either:
- an arrow "->", for a function type "(<type>, <type>...) -> <type>".
- an stack prefix, for example "[int::]", for a stack-modifying function type
  "(<type>, <type>...) [<stack-prefix>]->[<stack-prefix>] <type>"

f_expression_eof: FT LBRACKET LPAREN UNPACK 
##
## Ends in an error in state: 202.
##
## f_type -> LPAREN . loption(separated_nonempty_list(COMMA,f_type)) RPAREN ARROW f_type [ Z_IDENTIFIER UNFOLD TF RPAREN RANGLE PI OTHER_IDENTIFIER MINUS LPAREN LANGLE LAMBDA INTEGER IF0 FT FOLD E_IDENTIFIER COMMA A_IDENTIFIER ]
## f_type -> LPAREN . loption(separated_nonempty_list(COMMA,f_type)) RPAREN LBRACKET stack_prefix RBRACKET ARROW LBRACKET stack_prefix RBRACKET f_type [ Z_IDENTIFIER UNFOLD TF RPAREN RANGLE PI OTHER_IDENTIFIER MINUS LPAREN LANGLE LAMBDA INTEGER IF0 FT FOLD E_IDENTIFIER COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## LPAREN 
##

Parsing a type, we have parsed an opening parenthesis "(" so
far. Please write a complete type, for example "(int)" or an arrow
type "(int)->int".

f_expression_eof: FT LBRACKET LPAREN Z_IDENTIFIER COMMA UNPACK 
##
## Ends in an error in state: 211.
##
## separated_nonempty_list(COMMA,f_type) -> f_type COMMA . separated_nonempty_list(COMMA,f_type) [ RPAREN RANGLE ]
##
## The known suffix of the stack is as follows:
## f_type COMMA 
##

Parsing a sequence of types "<type>, <type>..., we have parsed the
beginning of a sequence "<type>," so far, and expect another type, for
example "int".

f_expression_eof: FT LBRACKET LPAREN Z_IDENTIFIER RANGLE 
##
## Ends in an error in state: 214.
##
## f_type -> LPAREN loption(separated_nonempty_list(COMMA,f_type)) . RPAREN ARROW f_type [ Z_IDENTIFIER UNFOLD TF RPAREN RANGLE PI OTHER_IDENTIFIER MINUS LPAREN LANGLE LAMBDA INTEGER IF0 FT FOLD E_IDENTIFIER COMMA A_IDENTIFIER ]
## f_type -> LPAREN loption(separated_nonempty_list(COMMA,f_type)) . RPAREN LBRACKET stack_prefix RBRACKET ARROW LBRACKET stack_prefix RBRACKET f_type [ Z_IDENTIFIER UNFOLD TF RPAREN RANGLE PI OTHER_IDENTIFIER MINUS LPAREN LANGLE LAMBDA INTEGER IF0 FT FOLD E_IDENTIFIER COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## LPAREN loption(separated_nonempty_list(COMMA,f_type)) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 210, spurious reduction of production separated_nonempty_list(COMMA,f_type) -> f_type 
## In state 206, spurious reduction of production loption(separated_nonempty_list(COMMA,f_type)) -> separated_nonempty_list(COMMA,f_type) 
##

Parsing a function type, we have parsed "(<type>, <type>..." so
far. We expect a more comma-separated types, or closing parenthesis
")", and then either
- an arrow "->", for a function type "(<type>, <type>...) -> <type>".
- an stack prefix, for example "[int::]", for a stack-modifying function type
  "(<type>, <type>...) [<stack-prefix>]->[<stack-prefix>] <type>"

f_expression_eof: FT LBRACKET LPAREN Z_IDENTIFIER Z_IDENTIFIER 
##
## Ends in an error in state: 210.
##
## separated_nonempty_list(COMMA,f_type) -> f_type . [ RPAREN RANGLE ]
## separated_nonempty_list(COMMA,f_type) -> f_type . COMMA separated_nonempty_list(COMMA,f_type) [ RPAREN RANGLE ]
##
## The known suffix of the stack is as follows:
## f_type 
##

Parsing a sequence of types "<type>, <type>..., we have parsed a type
so far, and expect a comma followed by more types, or the end of the
sequence.

f_expression_eof: FT LBRACKET UNPACK 
##
## Ends in an error in state: 261.
##
## f_simple_expression -> FT LBRACKET . f_type COMMA stack_typing_annot RBRACKET component [ Z_IDENTIFIER TIMES RPAREN RBRACE RANGLE PLUS PI OTHER_IDENTIFIER MINUS LPAREN LANGLE INTEGER FT E_IDENTIFIER EOF COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## FT LBRACKET 
##

Parsing a boundary expression
"FT[<type>, <stack-typing?>] <compoment>", we parsed "FT[" so far
and expect the return type of the boundary, for example "int".

f_expression_eof: FT LBRACKET Z_IDENTIFIER COMMA UNIT DOUBLECOLON UNPACK 
##
## Ends in an error in state: 46.
##
## list(__anonymous_0) -> value_type DOUBLECOLON . list(__anonymous_0) [ Z_IDENTIFIER TIMES ]
##
## The known suffix of the stack is as follows:
## value_type DOUBLECOLON 
##

Parsing a stack typing "<type> :: <type> ::.. [ <variable> | * ]", we
parsed a stack prefix "<type> :: <type> ::..." so far, and expect
either a stack type variable, for example "z", or the end-of-stack
symbol "*".

f_expression_eof: FT LBRACKET Z_IDENTIFIER COMMA UNIT Z_IDENTIFIER 
##
## Ends in an error in state: 45.
##
## list(__anonymous_0) -> value_type . DOUBLECOLON list(__anonymous_0) [ Z_IDENTIFIER TIMES ]
##
## The known suffix of the stack is as follows:
## value_type 
##

Parsing a stack typing "<type> :: <type> ::.. [ <variable> | * ]", we
parsed a stack prefix "<type> :: <type>" so far, and expect the
separator symbol "::".

f_expression_eof: FT LBRACKET Z_IDENTIFIER COMMA UNPACK 
##
## Ends in an error in state: 263.
##
## f_simple_expression -> FT LBRACKET f_type COMMA . stack_typing_annot RBRACKET component [ Z_IDENTIFIER TIMES RPAREN RBRACE RANGLE PLUS PI OTHER_IDENTIFIER MINUS LPAREN LANGLE INTEGER FT E_IDENTIFIER EOF COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## FT LBRACKET f_type COMMA 
##

Parsing a boundary expression
"FT[<type>, <stack-typing?>] <compoment>", we parsed "FT[<type>,"
so far and expect a stack typing, for example "int :: *".

f_expression_eof: FT LBRACKET Z_IDENTIFIER COMMA Z_IDENTIFIER RBRACKET Z_IDENTIFIER 
##
## Ends in an error in state: 266.
##
## f_simple_expression -> FT LBRACKET f_type COMMA stack_typing_annot RBRACKET . component [ Z_IDENTIFIER TIMES RPAREN RBRACE RANGLE PLUS PI OTHER_IDENTIFIER MINUS LPAREN LANGLE INTEGER FT E_IDENTIFIER EOF COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## FT LBRACKET f_type COMMA stack_typing_annot RBRACKET 
##

Parsing a boundary expression
"FT[<type>, <stack-typing?>] <compoment>", we parsed
"FT[<type>,<stack-typing?>]" so far, and expect a TAL component,
for example "( [mv r1, 0; halt int, * {r1}], [l -> <1>] )".

f_expression_eof: FT LBRACKET Z_IDENTIFIER COMMA Z_IDENTIFIER Z_IDENTIFIER 
##
## Ends in an error in state: 265.
##
## f_simple_expression -> FT LBRACKET f_type COMMA stack_typing_annot . RBRACKET component [ Z_IDENTIFIER TIMES RPAREN RBRACE RANGLE PLUS PI OTHER_IDENTIFIER MINUS LPAREN LANGLE INTEGER FT E_IDENTIFIER EOF COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## FT LBRACKET f_type COMMA stack_typing_annot 
##

Parsing a boundary expression
"FT[<type>, <stack-typing?>] <compoment>", we parsed
"FT[<type>, <stack-typing?>" so far, and expect a closing bracket "]".

f_expression_eof: FT LBRACKET Z_IDENTIFIER Z_IDENTIFIER 
##
## Ends in an error in state: 262.
##
## f_simple_expression -> FT LBRACKET f_type . COMMA stack_typing_annot RBRACKET component [ Z_IDENTIFIER TIMES RPAREN RBRACE RANGLE PLUS PI OTHER_IDENTIFIER MINUS LPAREN LANGLE INTEGER FT E_IDENTIFIER EOF COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## FT LBRACKET f_type 
##

Parsing a boundary expression
"FT[<type>, <stack-typing?>] <compoment>", we parsed "FT[<type>" so
far, and expect a comma followed by a stack typing, for example
", int :: unit" or ", ?".

f_expression_eof: FT Z_IDENTIFIER 
##
## Ends in an error in state: 260.
##
## f_simple_expression -> FT . LBRACKET f_type COMMA stack_typing_annot RBRACKET component [ Z_IDENTIFIER TIMES RPAREN RBRACE RANGLE PLUS PI OTHER_IDENTIFIER MINUS LPAREN LANGLE INTEGER FT E_IDENTIFIER EOF COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## FT 
##

Parsing a boundary expression
"FT[<type>, <stack-typing?>] <compoment>", we parsed "FT" and expect
a type and a stack typing, for example "[int, int :: z]" or
"[int, ?]".

f_expression_eof: IF0 UNPACK 
##
## Ends in an error in state: 259.
##
## f_expression -> IF0 . f_simple_expression f_simple_expression f_simple_expression [ RPAREN RBRACE RANGLE EOF COMMA ]
##
## The known suffix of the stack is as follows:
## IF0 
##

Parsing a conditional expression "if0 <expr> <expr> <expr>", we parsed
the keyword "if0" and expect an expression of integer type -- we
branch of whether the value is 0 or not.

f_expression_eof: IF0 Z_IDENTIFIER UNPACK 
##
## Ends in an error in state: 272.
##
## f_expression -> IF0 f_simple_expression . f_simple_expression f_simple_expression [ RPAREN RBRACE RANGLE EOF COMMA ]
##
## The known suffix of the stack is as follows:
## IF0 f_simple_expression 
##

Parsing a conditional expression "if0 <expr> <expr> <expr>", we parsed
"if0 <expr>" and expect two expressions, the first to evaluate if the
condition expression evalutes to 0, and the second otherwise.

f_expression_eof: IF0 Z_IDENTIFIER Z_IDENTIFIER UNPACK 
##
## Ends in an error in state: 273.
##
## f_expression -> IF0 f_simple_expression f_simple_expression . f_simple_expression [ RPAREN RBRACE RANGLE EOF COMMA ]
##
## The known suffix of the stack is as follows:
## IF0 f_simple_expression f_simple_expression 
##

Parsing a conditional expression "if0 <expr> <expr> <expr>", we parsed
"if0 <expr> <expr>" and expect an expression to evaluate if the
condition expression does not evaluate to 0.

f_expression_eof: LAMBDA LBRACKET BOX FORALL LBRACKET RBRACKET DOT LBRACE REGISTER COLON A_IDENTIFIER COMMA Z_IDENTIFIER 
##
## Ends in an error in state: 76.
##
## separated_nonempty_list(COMMA,decl(register,value_type)) -> decl(register,value_type) COMMA . separated_nonempty_list(COMMA,decl(register,value_type)) [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## decl(register,value_type) COMMA 
##

Parsing a register typing "<register>:<type>, <register>:<type>..."
we parsed a comma and wait for a "<register>:<type>" declaration, for
example "ra:int".

f_expression_eof: LAMBDA LBRACKET BOX FORALL LBRACKET RBRACKET DOT LBRACE REGISTER COLON A_IDENTIFIER Z_IDENTIFIER 
##
## Ends in an error in state: 75.
##
## separated_nonempty_list(COMMA,decl(register,value_type)) -> decl(register,value_type) . [ SEMICOLON ]
## separated_nonempty_list(COMMA,decl(register,value_type)) -> decl(register,value_type) . COMMA separated_nonempty_list(COMMA,decl(register,value_type)) [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## decl(register,value_type) 
##

Parsing a register typing "<register>:<type>, <register>:<type>..."
we parsed a "<register>:<type>" declaration and expect a comma ",".

f_expression_eof: LAMBDA LBRACKET BOX FORALL LBRACKET RBRACKET DOT LBRACE REGISTER COLON Z_IDENTIFIER 
##
## Ends in an error in state: 72.
##
## decl(register,value_type) -> register COLON . value_type [ SEMICOLON COMMA ]
##
## The known suffix of the stack is as follows:
## register COLON 
##

Parsing a register typing "<register>:<type>, <register>:<type>..."
we parsed a register and expect a type, for example "int".

f_expression_eof: LAMBDA LBRACKET BOX FORALL LBRACKET RBRACKET DOT LBRACE REGISTER Z_IDENTIFIER 
##
## Ends in an error in state: 71.
##
## decl(register,value_type) -> register . COLON value_type [ SEMICOLON COMMA ]
##
## The known suffix of the stack is as follows:
## register 
##

Parsing a register typing "<register>:<type>, <register>:<type>..."
we parsed a register and expect a colon ":", followed by a type.

f_expression_eof: LAMBDA LBRACKET BOX FORALL LBRACKET RBRACKET DOT LBRACE SEMICOLON UNPACK 
##
## Ends in an error in state: 44.
##
## heap_value_type -> FORALL type_env DOT LBRACE simple_register_typing SEMICOLON . stack_typing RBRACE return_marker [ Z_IDENTIFIER SEMICOLON RPAREN REGISTER RBRACKET RANGLE PACK OTHER_IDENTIFIER MINUS LPAREN LBRACKET LBRACE INTEGER FOLD E_IDENTIFIER DOUBLECOLON COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## FORALL type_env DOT LBRACE simple_register_typing SEMICOLON 
##

Parsing the type of a heap code block
"forall [<type-env>]. {<register-typing>; <stack-typing>} <return-marker>",
we parsed
"forall [<type-env>]. {<register-typing>;" so far and expect a stack typing,
for example "int :: unit :: z" or "*".

f_expression_eof: LAMBDA LBRACKET BOX FORALL LBRACKET RBRACKET DOT LBRACE SEMICOLON Z_IDENTIFIER RBRACE Z_IDENTIFIER 
##
## Ends in an error in state: 52.
##
## heap_value_type -> FORALL type_env DOT LBRACE simple_register_typing SEMICOLON stack_typing RBRACE . return_marker [ Z_IDENTIFIER SEMICOLON RPAREN REGISTER RBRACKET RANGLE PACK OTHER_IDENTIFIER MINUS LPAREN LBRACKET LBRACE INTEGER FOLD E_IDENTIFIER DOUBLECOLON COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## FORALL type_env DOT LBRACE simple_register_typing SEMICOLON stack_typing RBRACE 
##

Parsing the type of a heap code block
"forall [<type-env>]. {<register-typing>; <stack-typing>} <return-marker>",
we parsed "forall [<type-env>]. {<register-typing>; <stack-typing>}"
so far and expect a return marker, that is either:
- a register "r1",
- a stack position "3",
- a return variable "e",
- the end marker "end {<type>; <stack-typing>}" or
- the cross-language marker "out".

f_expression_eof: LAMBDA LBRACKET BOX FORALL LBRACKET RBRACKET DOT LBRACE SEMICOLON Z_IDENTIFIER Z_IDENTIFIER 
##
## Ends in an error in state: 51.
##
## heap_value_type -> FORALL type_env DOT LBRACE simple_register_typing SEMICOLON stack_typing . RBRACE return_marker [ Z_IDENTIFIER SEMICOLON RPAREN REGISTER RBRACKET RANGLE PACK OTHER_IDENTIFIER MINUS LPAREN LBRACKET LBRACE INTEGER FOLD E_IDENTIFIER DOUBLECOLON COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## FORALL type_env DOT LBRACE simple_register_typing SEMICOLON stack_typing 
##

Parsing the type of a heap code block
"forall [<type-env>]. {<register-typing>; <stack-typing>} <return-marker>",
we parsed "forall [<type-env>]. {<register-typing>; <stack-typing>" so
far and expect a closing brace followed by a return marker.

f_expression_eof: LAMBDA LBRACKET BOX FORALL LBRACKET RBRACKET DOT LBRACE Z_IDENTIFIER 
##
## Ends in an error in state: 42.
##
## heap_value_type -> FORALL type_env DOT LBRACE . simple_register_typing SEMICOLON stack_typing RBRACE return_marker [ Z_IDENTIFIER SEMICOLON RPAREN REGISTER RBRACKET RANGLE PACK OTHER_IDENTIFIER MINUS LPAREN LBRACKET LBRACE INTEGER FOLD E_IDENTIFIER DOUBLECOLON COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## FORALL type_env DOT LBRACE 
##

Parsing the type of a heap code block
"forall [<type-env>]. {<register-typing>; <stack-typing>} <return-marker>",
we parsed "forall [" so far and expect a type environment, for example
"a, e2, z']".

f_expression_eof: LAMBDA LBRACKET BOX FORALL LBRACKET RBRACKET DOT Z_IDENTIFIER 
##
## Ends in an error in state: 41.
##
## heap_value_type -> FORALL type_env DOT . LBRACE simple_register_typing SEMICOLON stack_typing RBRACE return_marker [ Z_IDENTIFIER SEMICOLON RPAREN REGISTER RBRACKET RANGLE PACK OTHER_IDENTIFIER MINUS LPAREN LBRACKET LBRACE INTEGER FOLD E_IDENTIFIER DOUBLECOLON COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## FORALL type_env DOT 
##

Parsing the type of a heap code block
"forall [<type-env>]. {<register-typing>; <stack-typing>} <return-marker>",
we parsed "forall [<type-env>]" so far and expect a register and stack typing,
for example "{ r1 : <int>, r2 : <unit>; int :: z2 }".

f_expression_eof: LAMBDA LBRACKET BOX FORALL LBRACKET RBRACKET Z_IDENTIFIER 
##
## Ends in an error in state: 40.
##
## heap_value_type -> FORALL type_env . DOT LBRACE simple_register_typing SEMICOLON stack_typing RBRACE return_marker [ Z_IDENTIFIER SEMICOLON RPAREN REGISTER RBRACKET RANGLE PACK OTHER_IDENTIFIER MINUS LPAREN LBRACKET LBRACE INTEGER FOLD E_IDENTIFIER DOUBLECOLON COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## FORALL type_env 
##

Parsing the type of a heap code block
"forall [<type-env>]. {<register-typing>; <stack-typing>} <return-marker>",
we parsed "forall [<type-env>]" so far and expect a dot followed by
a register and stack typing, for example
". { r1 : <int>, r2 : <unit>; int :: z2 }".

f_expression_eof: LAMBDA LBRACKET BOX FORALL LBRACKET UNPACK 
##
## Ends in an error in state: 27.
##
## type_env -> LBRACKET . simple_type_env RBRACKET [ LBRACE DOT ]
##
## The known suffix of the stack is as follows:
## LBRACKET 
##

Parsing a typing environment, we parsed the opening bracket "[" so
far, and expect a comma-separated list of type variables "a", stack
variables "z" or return marker variables "e", for example
"[a, e', z2]".

f_expression_eof: LAMBDA LBRACKET BOX FORALL LBRACKET Z_IDENTIFIER COMMA UNPACK 
##
## Ends in an error in state: 32.
##
## separated_nonempty_list(COMMA,type_env_elem) -> type_env_elem COMMA . separated_nonempty_list(COMMA,type_env_elem) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## type_env_elem COMMA 
##

Parsing a typing environment, we just parsed a comma "," and expect
a type variable "a", a stack variable "z" or a return marker variable
"e".

f_expression_eof: LAMBDA LBRACKET BOX FORALL LBRACKET Z_IDENTIFIER Z_IDENTIFIER 
##
## Ends in an error in state: 31.
##
## separated_nonempty_list(COMMA,type_env_elem) -> type_env_elem . [ RBRACKET ]
## separated_nonempty_list(COMMA,type_env_elem) -> type_env_elem . COMMA separated_nonempty_list(COMMA,type_env_elem) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## type_env_elem 
##

Parsing a typing environment, we expect a closing bracket "]" or
a comma "," followed by more environment variables.

f_expression_eof: LAMBDA LBRACKET BOX FORALL Z_IDENTIFIER 
##
## Ends in an error in state: 26.
##
## heap_value_type -> FORALL . type_env DOT LBRACE simple_register_typing SEMICOLON stack_typing RBRACE return_marker [ Z_IDENTIFIER SEMICOLON RPAREN REGISTER RBRACKET RANGLE PACK OTHER_IDENTIFIER MINUS LPAREN LBRACKET LBRACE INTEGER FOLD E_IDENTIFIER DOUBLECOLON COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## FORALL 
##

Parsing the type of a heap code block
"forall [<type-env>]. {<register-typing>; <stack-typing>} <return-marker>",
we parsed the "forall" keyword and expect a type environment, for example
"[a, e2, z']".

f_expression_eof: LAMBDA LBRACKET BOX Z_IDENTIFIER 
##
## Ends in an error in state: 25.
##
## value_type -> BOX . heap_value_type [ Z_IDENTIFIER SEMICOLON RPAREN REGISTER RBRACKET RANGLE PACK OTHER_IDENTIFIER MINUS LPAREN LBRACKET LBRACE INTEGER FOLD E_IDENTIFIER DOUBLECOLON COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## BOX 
##

Parsing a heap value type, we parsed the mutability marker "box" and
expect a value type, for example "<int, unit>" or
"forall [a,z] { r1:int; unit::* }. e"

f_expression_eof: LAMBDA LBRACKET EXISTS A_IDENTIFIER DOT Z_IDENTIFIER 
##
## Ends in an error in state: 24.
##
## existential_type -> EXISTS type_variable DOT . value_type [ Z_IDENTIFIER SEMICOLON RPAREN REGISTER RBRACKET RANGLE PACK OTHER_IDENTIFIER MINUS LPAREN LBRACKET LBRACE INTEGER FOLD E_IDENTIFIER DOUBLECOLON COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## EXISTS type_variable DOT 
##

Parsing an existential type "exists <variable>. <type>", we parsed
"exists <variable>." so far and expect a type.

f_expression_eof: LAMBDA LBRACKET EXISTS A_IDENTIFIER Z_IDENTIFIER 
##
## Ends in an error in state: 23.
##
## existential_type -> EXISTS type_variable . DOT value_type [ Z_IDENTIFIER SEMICOLON RPAREN REGISTER RBRACKET RANGLE PACK OTHER_IDENTIFIER MINUS LPAREN LBRACKET LBRACE INTEGER FOLD E_IDENTIFIER DOUBLECOLON COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## EXISTS type_variable 
##

Parsing an existential type "exists <variable>. <type>", we parsed
"exists <variable>" so far and expect a dot "." followed by a type.

f_expression_eof: LAMBDA LBRACKET EXISTS Z_IDENTIFIER 
##
## Ends in an error in state: 22.
##
## existential_type -> EXISTS . type_variable DOT value_type [ Z_IDENTIFIER SEMICOLON RPAREN REGISTER RBRACKET RANGLE PACK OTHER_IDENTIFIER MINUS LPAREN LBRACKET LBRACE INTEGER FOLD E_IDENTIFIER DOUBLECOLON COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## EXISTS 
##

Parsing an existential type "exists <variable>. <type>", we parsed
"exists" so far and expect a type variable "a".

f_expression_eof: LAMBDA LBRACKET MU A_IDENTIFIER DOT Z_IDENTIFIER 
##
## Ends in an error in state: 20.
##
## mu_type -> MU type_variable DOT . value_type [ Z_IDENTIFIER SEMICOLON RPAREN REGISTER RBRACKET RANGLE PACK OTHER_IDENTIFIER MINUS LPAREN LBRACKET LBRACE INTEGER FOLD E_IDENTIFIER DOUBLECOLON COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## MU type_variable DOT 
##

Parsing an recursive type "mu <variable>. <type>", we parsed
"mu <variable> ." so far and expect a type.

f_expression_eof: LAMBDA LBRACKET MU A_IDENTIFIER Z_IDENTIFIER 
##
## Ends in an error in state: 19.
##
## mu_type -> MU type_variable . DOT value_type [ Z_IDENTIFIER SEMICOLON RPAREN REGISTER RBRACKET RANGLE PACK OTHER_IDENTIFIER MINUS LPAREN LBRACKET LBRACE INTEGER FOLD E_IDENTIFIER DOUBLECOLON COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## MU type_variable 
##

Parsing an recursive type "mu <variable>. <type>", we parsed
"mu <variable> ." so far and expect a dot followed by a type.

f_expression_eof: LAMBDA LBRACKET MU Z_IDENTIFIER 
##
## Ends in an error in state: 18.
##
## mu_type -> MU . type_variable DOT value_type [ Z_IDENTIFIER SEMICOLON RPAREN REGISTER RBRACKET RANGLE PACK OTHER_IDENTIFIER MINUS LPAREN LBRACKET LBRACE INTEGER FOLD E_IDENTIFIER DOUBLECOLON COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## MU 
##

Parsing an recursive type "mu <variable>. <type>", we parsed the "mu"
keyword so far and expect a type variable "a".

f_expression_eof: LAMBDA LBRACKET REF LANGLE UNIT COMMA Z_IDENTIFIER 
##
## Ends in an error in state: 83.
##
## separated_nonempty_list(COMMA,value_type) -> value_type COMMA . separated_nonempty_list(COMMA,value_type) [ RANGLE ]
##
## The known suffix of the stack is as follows:
## value_type COMMA 
##

Parsing a sequence of types "<type>, <type>...", we parsed a comma ","
and expect a TAL type.

f_expression_eof: LAMBDA LBRACKET REF LANGLE UNIT Z_IDENTIFIER 
##
## Ends in an error in state: 82.
##
## separated_nonempty_list(COMMA,value_type) -> value_type . [ RANGLE ]
## separated_nonempty_list(COMMA,value_type) -> value_type . COMMA separated_nonempty_list(COMMA,value_type) [ RANGLE ]
##
## The known suffix of the stack is as follows:
## value_type 
##

Parsing a sequence of types "<type>, <type>...", we parsed a type
and expect a comma "," or the end of the sequence.

f_expression_eof: LAMBDA LBRACKET REF LANGLE Z_IDENTIFIER 
##
## Ends in an error in state: 17.
##
## tuple(value_type) -> LANGLE . loption(separated_nonempty_list(COMMA,value_type)) RANGLE [ Z_IDENTIFIER SEMICOLON RPAREN REGISTER RBRACKET RANGLE PACK OTHER_IDENTIFIER MINUS LPAREN LBRACKET LBRACE INTEGER FOLD E_IDENTIFIER DOUBLECOLON COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## LANGLE 
##

Parsing a tuple type "< <type>, <type>... >", we have parsed the
opening angle bracket "<" so far and expect a comma-separated list of
types.

f_expression_eof: LAMBDA LBRACKET REF Z_IDENTIFIER 
##
## Ends in an error in state: 16.
##
## value_type -> REF . tuple(value_type) [ Z_IDENTIFIER SEMICOLON RPAREN REGISTER RBRACKET RANGLE PACK OTHER_IDENTIFIER MINUS LPAREN LBRACKET LBRACE INTEGER FOLD E_IDENTIFIER DOUBLECOLON COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## REF 
##

Parsing a mutable tuple type "ref < <type>, <type>... >",
we parsed the "ref" keyword so far and expect a tuple type,
for example "<int, a, unit>".

f_expression_eof: LAMBDA LBRACKET UNIT COMMA 
##
## Ends in an error in state: 170.
##
## stack_prefix -> value_type . rest_stack_prefix [ RBRACKET COMMA ]
##
## The known suffix of the stack is as follows:
## value_type 
##

Parsing a stack-modifying lambda-expression
"lam [<stack-prefix>] [<stack-prefix>] (<args>). <expr>", we parsed
"lam [<stack-prefix>" so far and expect a closing bracket.

f_expression_eof: LAMBDA LBRACKET UNIT DOUBLECOLON Z_IDENTIFIER 
##
## Ends in an error in state: 171.
##
## rest_stack_prefix -> DOUBLECOLON . [ RBRACKET COMMA ]
## rest_stack_prefix -> DOUBLECOLON . value_type rest_stack_prefix [ RBRACKET COMMA ]
##
## The known suffix of the stack is as follows:
## DOUBLECOLON 
##

We expect a stack prefix "<type> :: <type> :: ...",
for example "int :: unit ::" or the empty prefix "::".

f_expression_eof: LAMBDA LBRACKET Z_IDENTIFIER 
##
## Ends in an error in state: 251.
##
## f_expression -> LAMBDA LBRACKET . stack_prefix RBRACKET LBRACKET stack_prefix RBRACKET f_telescope DOT f_expression [ RPAREN RBRACE RANGLE EOF COMMA ]
##
## The known suffix of the stack is as follows:
## LAMBDA LBRACKET 
##

Parsing a stack-modifying lambda-expression
"lam [<stack-prefix>] [<stack-prefix>] (<args>). <expr>", we parsed
"lam [" so far and expect a stack prefix, for example "int :: unit ::"
or the empty prefix "::".

f_expression_eof: LAMBDA LPAREN RPAREN DOT UNPACK 
##
## Ends in an error in state: 296.
##
## f_expression -> LAMBDA f_telescope DOT . f_expression [ RPAREN RBRACE RANGLE EOF COMMA ]
##
## The known suffix of the stack is as follows:
## LAMBDA f_telescope DOT 
##

Parsing a lambda-expression "lam (<args>). <expr>", we parsed
"lam (<args>)." and expect an expression, the body of the lambda.

f_expression_eof: LAMBDA LPAREN RPAREN Z_IDENTIFIER 
##
## Ends in an error in state: 295.
##
## f_expression -> LAMBDA f_telescope . DOT f_expression [ RPAREN RBRACE RANGLE EOF COMMA ]
##
## The known suffix of the stack is as follows:
## LAMBDA f_telescope 
##

Parsing a lambda-expression "lam (<args>). <expr>", we parsed
"lam (<args>)" and expect a dot followed by the body of the lambda.

f_expression_eof: LAMBDA LPAREN UNPACK 
##
## Ends in an error in state: 240.
##
## f_telescope -> LPAREN . loption(separated_nonempty_list(COMMA,decl(f_term_variable,f_type))) RPAREN [ DOT ]
##
## The known suffix of the stack is as follows:
## LPAREN 
##

Parsing the arguments of lambda-expression
"(<var>:<type>, <var>:<type>...)", we parsed the opening parenthesis
"(" so far and expect a term variable and its type, for example
"x:int".

f_expression_eof: LAMBDA LPAREN Z_IDENTIFIER COLON A_IDENTIFIER COMMA UNPACK 
##
## Ends in an error in state: 249.
##
## separated_nonempty_list(COMMA,decl(f_term_variable,f_type)) -> decl(f_term_variable,f_type) COMMA . separated_nonempty_list(COMMA,decl(f_term_variable,f_type)) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## decl(f_term_variable,f_type) COMMA 
##

Parsing the arguments of lambda-expression
"(<var>:<type>, <var>:<type>...)", we parsed a comma "," and expect
more arguments, for example "x:int".

f_expression_eof: LAMBDA LPAREN Z_IDENTIFIER COLON A_IDENTIFIER Z_IDENTIFIER 
##
## Ends in an error in state: 248.
##
## separated_nonempty_list(COMMA,decl(f_term_variable,f_type)) -> decl(f_term_variable,f_type) . [ RPAREN ]
## separated_nonempty_list(COMMA,decl(f_term_variable,f_type)) -> decl(f_term_variable,f_type) . COMMA separated_nonempty_list(COMMA,decl(f_term_variable,f_type)) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## decl(f_term_variable,f_type) 
##

Parsing the arguments of lambda-expression
"(<var>:<type>, <var>:<type>...)", we parsed a comma "," and expect a closing
parenthesis or more arguments, for example ", x:int, y:(int)->int)".

f_expression_eof: LAMBDA LPAREN Z_IDENTIFIER COLON UNPACK 
##
## Ends in an error in state: 246.
##
## decl(f_term_variable,f_type) -> f_term_variable COLON . f_type [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## f_term_variable COLON 
##

Parsing the arguments of lambda-expression
"(<var>:<type>, <var>:<type>...)", we parsed "<var>:" so far and
expect a type, for example "int".

f_expression_eof: LAMBDA LPAREN Z_IDENTIFIER Z_IDENTIFIER 
##
## Ends in an error in state: 245.
##
## decl(f_term_variable,f_type) -> f_term_variable . COLON f_type [ RPAREN COMMA ]
##
## The known suffix of the stack is as follows:
## f_term_variable 
##

Parsing the arguments of lambda-expression
"(<var>:<type>, <var>:<type>...)", we parsed a variable and
expect the symbol ":" followed by a type, for example ": int".

f_expression_eof: LAMBDA Z_IDENTIFIER 
##
## Ends in an error in state: 239.
##
## f_expression -> LAMBDA . f_telescope DOT f_expression [ RPAREN RBRACE RANGLE EOF COMMA ]
## f_expression -> LAMBDA . LBRACKET stack_prefix RBRACKET LBRACKET stack_prefix RBRACKET f_telescope DOT f_expression [ RPAREN RBRACE RANGLE EOF COMMA ]
##
## The known suffix of the stack is as follows:
## LAMBDA 
##

Parsing a lambda-expression, we parsed the "lam" keyword and expect:
- a parenthesis "(", for a pure lambda-expression "lam (x:int, y:unit). e"
- or stack prefix, for a stack-modifying lambda-expression
  "lam [<stack-prefix>][<stack-prefix>](x:int, y:unit). e".

f_expression_eof: LANGLE UNPACK 
##
## Ends in an error in state: 238.
##
## tuple(f_expression) -> LANGLE . loption(separated_nonempty_list(COMMA,f_expression)) RANGLE [ Z_IDENTIFIER TIMES RPAREN RBRACE RANGLE PLUS PI OTHER_IDENTIFIER MINUS LPAREN LANGLE INTEGER FT E_IDENTIFIER EOF COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## LANGLE 
##

Parsing a tuple expression "< <expr>, <expr>... >", we parsed
an opening angle backet "<" so far and expect a comma-separated
list of expressions, for example "1, ()>".

f_expression_eof: LANGLE Z_IDENTIFIER COMMA UNPACK 
##
## Ends in an error in state: 302.
##
## separated_nonempty_list(COMMA,f_expression) -> f_expression COMMA . separated_nonempty_list(COMMA,f_expression) [ RANGLE ]
##
## The known suffix of the stack is as follows:
## f_expression COMMA 
##

Parsing a tuple expression "< <expr>, <expr>... >", we just parsed
a comma and expect other comma-separated expressions.

f_expression_eof: LANGLE Z_IDENTIFIER RPAREN 
##
## Ends in an error in state: 301.
##
## separated_nonempty_list(COMMA,f_expression) -> f_expression . [ RANGLE ]
## separated_nonempty_list(COMMA,f_expression) -> f_expression . COMMA separated_nonempty_list(COMMA,f_expression) [ RANGLE ]
##
## The known suffix of the stack is as follows:
## f_expression 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 279, spurious reduction of production f_app_expression -> f_simple_expression 
## In state 287, spurious reduction of production f_arith_expression -> f_app_expression 
## In state 284, spurious reduction of production f_expression -> f_arith_expression 
##

Parsing a tuple expression "< <expr>, <expr>... >", we just parsed an
expression and expect a closing angle bracket ">", or a comma and
more expressions.

f_expression_eof: LPAREN UNPACK 
##
## Ends in an error in state: 236.
##
## f_simple_expression -> LPAREN . RPAREN [ Z_IDENTIFIER TIMES RPAREN RBRACE RANGLE PLUS PI OTHER_IDENTIFIER MINUS LPAREN LANGLE INTEGER FT E_IDENTIFIER EOF COMMA A_IDENTIFIER ]
## f_simple_expression -> LPAREN . f_expression RPAREN [ Z_IDENTIFIER TIMES RPAREN RBRACE RANGLE PLUS PI OTHER_IDENTIFIER MINUS LPAREN LANGLE INTEGER FT E_IDENTIFIER EOF COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## LPAREN 
##

Parsing an expression, we parsed an opening parenthesis "(" and expect
a sub-expression, or a closing parenthesis ")" to form the unit value
"()".

f_expression_eof: LPAREN Z_IDENTIFIER RBRACE 
##
## Ends in an error in state: 304.
##
## f_simple_expression -> LPAREN f_expression . RPAREN [ Z_IDENTIFIER TIMES RPAREN RBRACE RANGLE PLUS PI OTHER_IDENTIFIER MINUS LPAREN LANGLE INTEGER FT E_IDENTIFIER EOF COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## LPAREN f_expression 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 279, spurious reduction of production f_app_expression -> f_simple_expression 
## In state 287, spurious reduction of production f_arith_expression -> f_app_expression 
## In state 284, spurious reduction of production f_expression -> f_arith_expression 
##

Parsing an expression, we parsed "( <expr>" so far and expect
a closing parenthesis ")".

f_expression_eof: MINUS INTEGER Z_IDENTIFIER 
##
## Ends in an error in state: 284.
##
## f_arith_expression -> f_arith_expression . PLUS f_arith_expression [ TIMES RPAREN RBRACE RANGLE PLUS MINUS EOF COMMA ]
## f_arith_expression -> f_arith_expression . MINUS f_arith_expression [ TIMES RPAREN RBRACE RANGLE PLUS MINUS EOF COMMA ]
## f_arith_expression -> f_arith_expression . TIMES f_arith_expression [ TIMES RPAREN RBRACE RANGLE PLUS MINUS EOF COMMA ]
## f_expression -> f_arith_expression . [ RPAREN RBRACE RANGLE EOF COMMA ]
##
## The known suffix of the stack is as follows:
## f_arith_expression 
##

Parsing an arithmetic expression, we expect an infix operator "+", "-"
or "*", or the end of the expression.

f_expression_eof: MINUS Z_IDENTIFIER 
##
## Ends in an error in state: 234.
##
## f_arith_expression -> MINUS . nat [ TIMES RPAREN RBRACE RANGLE PLUS MINUS EOF COMMA ]
##
## The known suffix of the stack is as follows:
## MINUS 
##

Parsing an expression, we parsed a unary negation "-" so far, and
expect an integer literal to form a negative integer literal, such as
"-3".

f_expression_eof: PI INTEGER LPAREN UNPACK 
##
## Ends in an error in state: 233.
##
## f_simple_expression -> PI nat LPAREN . f_expression RPAREN [ Z_IDENTIFIER TIMES RPAREN RBRACE RANGLE PLUS PI OTHER_IDENTIFIER MINUS LPAREN LANGLE INTEGER FT E_IDENTIFIER EOF COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## PI nat LPAREN 
##

Parsing a projection expression "pi <nat> (<expr>)", we parsed "pi
<nat> (" so far and expect a sub-expression.

f_expression_eof: PI INTEGER LPAREN Z_IDENTIFIER RBRACE 
##
## Ends in an error in state: 306.
##
## f_simple_expression -> PI nat LPAREN f_expression . RPAREN [ Z_IDENTIFIER TIMES RPAREN RBRACE RANGLE PLUS PI OTHER_IDENTIFIER MINUS LPAREN LANGLE INTEGER FT E_IDENTIFIER EOF COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## PI nat LPAREN f_expression 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 279, spurious reduction of production f_app_expression -> f_simple_expression 
## In state 287, spurious reduction of production f_arith_expression -> f_app_expression 
## In state 284, spurious reduction of production f_expression -> f_arith_expression 
##

Parsing a projection expression "pi <nat> (<expr>)", we parsed
"pi <nat> (<expr>" so far and expect a closing parenthesis.

f_expression_eof: PI INTEGER Z_IDENTIFIER 
##
## Ends in an error in state: 232.
##
## f_simple_expression -> PI nat . LPAREN f_expression RPAREN [ Z_IDENTIFIER TIMES RPAREN RBRACE RANGLE PLUS PI OTHER_IDENTIFIER MINUS LPAREN LANGLE INTEGER FT E_IDENTIFIER EOF COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## PI nat 
##

Parsing a projection expression "pi <nat> (<expr>)", we parsed
"pi <nat>" so far and expect an opening parenthesis.

f_expression_eof: PI Z_IDENTIFIER 
##
## Ends in an error in state: 231.
##
## f_simple_expression -> PI . nat LPAREN f_expression RPAREN [ Z_IDENTIFIER TIMES RPAREN RBRACE RANGLE PLUS PI OTHER_IDENTIFIER MINUS LPAREN LANGLE INTEGER FT E_IDENTIFIER EOF COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## PI 
##

Parsing a projection expression "pi <nat> (<expr>)", we parsed "pi" so
far and expect the project index, for example "2", followed by
a parenthesized expression.

f_expression_eof: UNFOLD UNPACK 
##
## Ends in an error in state: 230.
##
## f_expression -> UNFOLD . f_expression [ RPAREN RBRACE RANGLE EOF COMMA ]
##
## The known suffix of the stack is as follows:
## UNFOLD 
##

Parsing an unfold expression "unfold <expr>", we parsed the "unfold"
keyword and expect an expression.

f_expression_eof: UNPACK 
##
## Ends in an error in state: 386.
##
## f_expression_eof' -> . f_expression_eof [ # ]
##
## The known suffix of the stack is as follows:
## 
##

We expect a valid F expression.

f_expression_eof: Z_IDENTIFIER MINUS UNPACK 
##
## Ends in an error in state: 290.
##
## f_arith_expression -> f_arith_expression MINUS . f_arith_expression [ TIMES RPAREN RBRACE RANGLE PLUS MINUS EOF COMMA ]
##
## The known suffix of the stack is as follows:
## f_arith_expression MINUS 
##

Parsing an arithmetic expression, we parsed "<expr> -" so far and
expect an expression.

f_expression_eof: Z_IDENTIFIER PLUS MINUS INTEGER Z_IDENTIFIER 
##
## Ends in an error in state: 289.
##
## f_arith_expression -> f_arith_expression . PLUS f_arith_expression [ TIMES RPAREN RBRACE RANGLE PLUS MINUS EOF COMMA ]
## f_arith_expression -> f_arith_expression PLUS f_arith_expression . [ TIMES RPAREN RBRACE RANGLE PLUS MINUS EOF COMMA ]
## f_arith_expression -> f_arith_expression . MINUS f_arith_expression [ TIMES RPAREN RBRACE RANGLE PLUS MINUS EOF COMMA ]
## f_arith_expression -> f_arith_expression . TIMES f_arith_expression [ TIMES RPAREN RBRACE RANGLE PLUS MINUS EOF COMMA ]
##
## The known suffix of the stack is as follows:
## f_arith_expression PLUS f_arith_expression 
##

Parsing an arithmetic expression, we expect an infix operator "+", "-"
or "*", or the end of the expression.

f_expression_eof: Z_IDENTIFIER RPAREN 
##
## Ends in an error in state: 388.
##
## f_expression_eof -> f_expression . EOF [ # ]
##
## The known suffix of the stack is as follows:
## f_expression 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 279, spurious reduction of production f_app_expression -> f_simple_expression 
## In state 287, spurious reduction of production f_arith_expression -> f_app_expression 
## In state 284, spurious reduction of production f_expression -> f_arith_expression 
##

We expect a valid expression.

f_expression_eof: Z_IDENTIFIER UNPACK 
##
## Ends in an error in state: 279.
##
## f_app_expression -> f_simple_expression . [ TIMES RPAREN RBRACE RANGLE PLUS MINUS EOF COMMA ]
## f_app_expression -> f_simple_expression . nonempty_list(f_simple_expression) [ TIMES RPAREN RBRACE RANGLE PLUS MINUS EOF COMMA ]
##
## The known suffix of the stack is as follows:
## f_simple_expression 
##

We expect a valid expression.

f_expression_eof: Z_IDENTIFIER Z_IDENTIFIER UNPACK 
##
## Ends in an error in state: 281.
##
## nonempty_list(f_simple_expression) -> f_simple_expression . [ TIMES RPAREN RBRACE RANGLE PLUS MINUS EOF COMMA ]
## nonempty_list(f_simple_expression) -> f_simple_expression . nonempty_list(f_simple_expression) [ TIMES RPAREN RBRACE RANGLE PLUS MINUS EOF COMMA ]
##
## The known suffix of the stack is as follows:
## f_simple_expression 
##

We expect a valid expression.

component_eof: LPAREN LBRACKET BALLOC REGISTER COMMA Z_IDENTIFIER 
##
## Ends in an error in state: 329.
##
## single_instruction -> BALLOC register COMMA . nat [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## BALLOC register COMMA 
##

Parsing an allocation instruction "balloc <reg>, <nat>;",
we parsed "balloc <reg>," so far and expect a number.

component_eof: LPAREN LBRACKET BALLOC REGISTER Z_IDENTIFIER 
##
## Ends in an error in state: 328.
##
## single_instruction -> BALLOC register . COMMA nat [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## BALLOC register 
##

Parsing a tuple-allocation instruction "balloc <reg>, <nat>;", we
parsed "balloc <reg>" so far and expect a comma followed by a number.

component_eof: LPAREN LBRACKET BALLOC Z_IDENTIFIER 
##
## Ends in an error in state: 327.
##
## single_instruction -> BALLOC . register COMMA nat [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## BALLOC 
##

Parsing a tuple-allocation instruction "balloc <reg>, <nat>;", we
parsed the "balloc" keyword and expect a register argument: "r1",
"r2"... "r7" or "ra".

component_eof: LPAREN LBRACKET BNZ REGISTER COMMA UNPACK 
##
## Ends in an error in state: 325.
##
## single_instruction -> BNZ register COMMA . small_value [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## BNZ register COMMA 
##

Parsing a conditional jump instruction "bnz <reg>, <value>;", we
parsed "bnz <reg>," so far and expect a value, for example "1".

component_eof: LPAREN LBRACKET BNZ REGISTER Z_IDENTIFIER 
##
## Ends in an error in state: 324.
##
## single_instruction -> BNZ register . COMMA small_value [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## BNZ register 
##

Parsing a conditional jump instruction "bnz <reg>, <value>;", we
parsed "bnz <reg>" so far and expect a comma ",".

component_eof: LPAREN LBRACKET BNZ Z_IDENTIFIER 
##
## Ends in an error in state: 323.
##
## single_instruction -> BNZ . register COMMA small_value [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## BNZ 
##

Parsing a conditional jump instruction "bnz <reg>, <value>;", we
parsed the "bnz" keyword so far and expect a register "r1",
"r2"... "r7" or "ra".

component_eof: LPAREN LBRACKET CALL UNPACK 
##
## Ends in an error in state: 316.
##
## final_instruction -> CALL . small_value LBRACE stack_typing COMMA return_marker RBRACE [ SEMICOLON RBRACKET ]
##
## The known suffix of the stack is as follows:
## CALL 
##

Parsing a call instruction
"call <value> {<stack-typing>, <return-marker>}", we parsed the "call"
keyword so far and expect a value, for example "ra".

component_eof: LPAREN LBRACKET CALL Z_IDENTIFIER LBRACE UNPACK 
##
## Ends in an error in state: 318.
##
## final_instruction -> CALL small_value LBRACE . stack_typing COMMA return_marker RBRACE [ SEMICOLON RBRACKET ]
##
## The known suffix of the stack is as follows:
## CALL small_value LBRACE 
##

Parsing a call instruction
"call <value> {<stack-typing>, <return-marker>}", we parsed
"call <value> {" so far and expect a stack typing, for example "z" or
"int :: *".

component_eof: LPAREN LBRACKET CALL Z_IDENTIFIER LBRACE Z_IDENTIFIER COMMA REGISTER Z_IDENTIFIER 
##
## Ends in an error in state: 321.
##
## final_instruction -> CALL small_value LBRACE stack_typing COMMA return_marker . RBRACE [ SEMICOLON RBRACKET ]
##
## The known suffix of the stack is as follows:
## CALL small_value LBRACE stack_typing COMMA return_marker 
##

Parsing a call instruction
"call <value> {<stack-typing>, <return-marker>}", we parsed
"call <value> {<stack-typing>, <return-marker>" so far and expect
a closing brace "}".

component_eof: LPAREN LBRACKET CALL Z_IDENTIFIER LBRACE Z_IDENTIFIER COMMA Z_IDENTIFIER 
##
## Ends in an error in state: 320.
##
## final_instruction -> CALL small_value LBRACE stack_typing COMMA . return_marker RBRACE [ SEMICOLON RBRACKET ]
##
## The known suffix of the stack is as follows:
## CALL small_value LBRACE stack_typing COMMA 
##

Parsing a call instruction
"call <value> {<stack-typing>, <return-marker>}", we parsed
"call <value> {<stack-typing>," so far and expect a return marker, that is either:
- a register "r1",
- a stack position "3",
- a return variable "e",
- the end marker "end {<type>; <stack-typing>}" or
- the cross-language marker "out".

component_eof: LPAREN LBRACKET CALL Z_IDENTIFIER LBRACE Z_IDENTIFIER Z_IDENTIFIER 
##
## Ends in an error in state: 319.
##
## final_instruction -> CALL small_value LBRACE stack_typing . COMMA return_marker RBRACE [ SEMICOLON RBRACKET ]
##
## The known suffix of the stack is as follows:
## CALL small_value LBRACE stack_typing 
##

Parsing a call instruction
"call <value> {<stack-typing>, <return-marker>}", we parsed
"call <value> {<stack-typing>" so far and expect a comma "," followed
by a return marker.

component_eof: LPAREN LBRACKET CALL Z_IDENTIFIER SEMICOLON 
##
## Ends in an error in state: 317.
##
## final_instruction -> CALL small_value . LBRACE stack_typing COMMA return_marker RBRACE [ SEMICOLON RBRACKET ]
##
## The known suffix of the stack is as follows:
## CALL small_value 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 103, spurious reduction of production small_value -> simple_small_value 
##

Parsing a call instruction
"call <value> {<stack-typing>, <return-marker>}", we parsed
"call <value>" so far and expect an opening brace "{".

component_eof: LPAREN LBRACKET HALT UNIT COMMA UNPACK 
##
## Ends in an error in state: 313.
##
## final_instruction -> HALT value_type COMMA . stack_typing bracereg [ SEMICOLON RBRACKET ]
##
## The known suffix of the stack is as follows:
## HALT value_type COMMA 
##

Parsing a halt instruction "halt <type>, <stack typing> {<register>}", we
parsed "halt <type>, <stack typing> {<register>}" so far and expect a
stack typing.

component_eof: LPAREN LBRACKET HALT UNIT COMMA Z_IDENTIFIER Z_IDENTIFIER 
##
## Ends in an error in state: 314.
##
## final_instruction -> HALT value_type COMMA stack_typing . bracereg [ SEMICOLON RBRACKET ]
##
## The known suffix of the stack is as follows:
## HALT value_type COMMA stack_typing 
##

Parsing a halt instruction "halt <type>, <stack typing> {<register>}", we
parsed "halt <type>, <stack typing>" so far and expect an opening brace "{",
followed by the result register, for example "r1".

component_eof: LPAREN LBRACKET HALT UNIT Z_IDENTIFIER 
##
## Ends in an error in state: 312.
##
## final_instruction -> HALT value_type . COMMA stack_typing bracereg [ SEMICOLON RBRACKET ]
##
## The known suffix of the stack is as follows:
## HALT value_type 
##

Parsing a halt instruction "halt <type>, <stack typing> {<register>}", we
parsed "halt <type>" so far and expect a comma "," followed by the result
stack typing, for example "int :: z" or "*".

component_eof: LPAREN LBRACKET HALT Z_IDENTIFIER 
##
## Ends in an error in state: 311.
##
## final_instruction -> HALT . value_type COMMA stack_typing bracereg [ SEMICOLON RBRACKET ]
##
## The known suffix of the stack is as follows:
## HALT 
##

Parsing a halt instruction "halt <type>, <stack typing> {<register>}", we
parsed the "halt" keyword and expect the result type, for example "int".

component_eof: LPAREN LBRACKET IMPORT REGISTER COMMA UNPACK 
##
## Ends in an error in state: 192.
##
## single_instruction -> IMPORT register COMMA . stack_typing_variable AS stack_typing COMMA f_type TF LBRACE f_expression RBRACE [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## IMPORT register COMMA 
##

Parsing an import instruction
"import <register>, <stack variable> as <stack typing>, <type> TF{ <expr> }",
we parsed "import <register>," so far and expect a stack variable.

component_eof: LPAREN LBRACKET IMPORT REGISTER COMMA Z_IDENTIFIER AS UNPACK 
##
## Ends in an error in state: 194.
##
## single_instruction -> IMPORT register COMMA stack_typing_variable AS . stack_typing COMMA f_type TF LBRACE f_expression RBRACE [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## IMPORT register COMMA stack_typing_variable AS 
##

Parsing an import instruction
"import <register>, <stack variable> as <stack typing>, <type> TF{ <expr> }",
we parsed "import <register>, <stack variable> as" so far and expect
a stack typing.

component_eof: LPAREN LBRACKET IMPORT REGISTER COMMA Z_IDENTIFIER AS Z_IDENTIFIER COMMA UNPACK 
##
## Ends in an error in state: 196.
##
## single_instruction -> IMPORT register COMMA stack_typing_variable AS stack_typing COMMA . f_type TF LBRACE f_expression RBRACE [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## IMPORT register COMMA stack_typing_variable AS stack_typing COMMA 
##

Parsing an import instruction
"import <register>, <stack variable> as <stack typing>, <type> TF{ <expr> }",
we parsed "import <register>, <stack variable> as <stack typing>," so far and expect
a type.

component_eof: LPAREN LBRACKET IMPORT REGISTER COMMA Z_IDENTIFIER AS Z_IDENTIFIER COMMA Z_IDENTIFIER TF LBRACE UNPACK 
##
## Ends in an error in state: 229.
##
## single_instruction -> IMPORT register COMMA stack_typing_variable AS stack_typing COMMA f_type TF LBRACE . f_expression RBRACE [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## IMPORT register COMMA stack_typing_variable AS stack_typing COMMA f_type TF LBRACE 
##

Parsing an import instruction
"import <register>, <stack variable> as <stack typing>, <type> TF{ <expr> }",
we parsed "import <register>, <stack variable> as <stack typing>,
<type> TF{" so far and expect a F expression.

component_eof: LPAREN LBRACKET IMPORT REGISTER COMMA Z_IDENTIFIER AS Z_IDENTIFIER COMMA Z_IDENTIFIER TF LBRACE Z_IDENTIFIER RPAREN 
##
## Ends in an error in state: 309.
##
## single_instruction -> IMPORT register COMMA stack_typing_variable AS stack_typing COMMA f_type TF LBRACE f_expression . RBRACE [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## IMPORT register COMMA stack_typing_variable AS stack_typing COMMA f_type TF LBRACE f_expression 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 279, spurious reduction of production f_app_expression -> f_simple_expression 
## In state 287, spurious reduction of production f_arith_expression -> f_app_expression 
## In state 284, spurious reduction of production f_expression -> f_arith_expression 
##

Parsing an import instruction
"import <register>, <stack variable> as <stack typing>, <type> TF{ <expr> }",
we parsed
"import <register>, <stack variable> as <stack typing>, <type> TF{ <expr>"
so far and expect a closing bracket "}".

component_eof: LPAREN LBRACKET IMPORT REGISTER COMMA Z_IDENTIFIER AS Z_IDENTIFIER COMMA Z_IDENTIFIER TF Z_IDENTIFIER 
##
## Ends in an error in state: 228.
##
## single_instruction -> IMPORT register COMMA stack_typing_variable AS stack_typing COMMA f_type TF . LBRACE f_expression RBRACE [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## IMPORT register COMMA stack_typing_variable AS stack_typing COMMA f_type TF 
##

Parsing an import instruction
"import <register>, <stack variable> as <stack typing>, <type> TF{ <expr> }",
we parsed
"import <register>, <stack variable> as <stack typing>, <type> TF" so
far and expect a bracketed F expression "{ <expr> }".

component_eof: LPAREN LBRACKET IMPORT REGISTER COMMA Z_IDENTIFIER AS Z_IDENTIFIER COMMA Z_IDENTIFIER Z_IDENTIFIER 
##
## Ends in an error in state: 227.
##
## single_instruction -> IMPORT register COMMA stack_typing_variable AS stack_typing COMMA f_type . TF LBRACE f_expression RBRACE [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## IMPORT register COMMA stack_typing_variable AS stack_typing COMMA f_type 
##

Parsing an import instruction
"import <register>, <stack variable> as <stack typing>, <type> TF{ <expr> }",
we parsed
"import <register>, <stack variable> as <stack typing>, <type>" so far
and expect F expression within a boundary "TF{ <expr> }".

component_eof: LPAREN LBRACKET IMPORT REGISTER COMMA Z_IDENTIFIER AS Z_IDENTIFIER Z_IDENTIFIER 
##
## Ends in an error in state: 195.
##
## single_instruction -> IMPORT register COMMA stack_typing_variable AS stack_typing . COMMA f_type TF LBRACE f_expression RBRACE [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## IMPORT register COMMA stack_typing_variable AS stack_typing 
##

Parsing an import instruction
"import <register>, <stack variable> as <stack typing>, <type> TF{ <expr> }",
we parsed
"import <register>, <stack variable> as <stack typing>" so far
and expect a comma "," followed by a type.

component_eof: LPAREN LBRACKET IMPORT REGISTER COMMA Z_IDENTIFIER Z_IDENTIFIER 
##
## Ends in an error in state: 193.
##
## single_instruction -> IMPORT register COMMA stack_typing_variable . AS stack_typing COMMA f_type TF LBRACE f_expression RBRACE [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## IMPORT register COMMA stack_typing_variable 
##

Parsing an import instruction
"import <register>, <stack variable> as <stack typing>, <type> TF{ <expr> }",
we parsed "import <register>, <stack variable>" and expect the "as"
keyword followed by a stack typing.

component_eof: LPAREN LBRACKET IMPORT REGISTER Z_IDENTIFIER 
##
## Ends in an error in state: 191.
##
## single_instruction -> IMPORT register . COMMA stack_typing_variable AS stack_typing COMMA f_type TF LBRACE f_expression RBRACE [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## IMPORT register 
##

Parsing an import instruction
"import <register>, <stack variable> as <stack typing>, <type> TF{ <expr> }",
we parsed "import <register>" and expect the binding of a stack typing
to a start variable, "<stack variable> as <stack typing>" -- don't ask
me about the order.

component_eof: LPAREN LBRACKET IMPORT Z_IDENTIFIER 
##
## Ends in an error in state: 190.
##
## single_instruction -> IMPORT . register COMMA stack_typing_variable AS stack_typing COMMA f_type TF LBRACE f_expression RBRACE [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## IMPORT 
##

Parsing an import instruction
"import <register>, <stack variable> as <stack typing>, <type> TF{ <expr> }",
we parsed the "import" keyword so far and expect the register in which
to store the imported value.

component_eof: LPAREN LBRACKET JMP FOLD LPAREN MU A_IDENTIFIER DOT A_IDENTIFIER RPAREN UNPACK 
##
## Ends in an error in state: 99.
##
## fold(small_value) -> FOLD LPAREN mu_type RPAREN . small_value [ SEMICOLON RPAREN RBRACKET RANGLE LBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## FOLD LPAREN mu_type RPAREN 
##

Parsing a folded value "fold <mu-type> <value>", we have parsed
"fold <mu-type>" and now expect an assembly value, for example a register
"r1".

component_eof: LPAREN LBRACKET JMP FOLD LPAREN MU A_IDENTIFIER DOT A_IDENTIFIER Z_IDENTIFIER 
##
## Ends in an error in state: 98.
##
## fold(small_value) -> FOLD LPAREN mu_type . RPAREN small_value [ SEMICOLON RPAREN RBRACKET RANGLE LBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## FOLD LPAREN mu_type 
##

Parsing a folded value "fold <mu-type> <value>", we have parsed
"fold (<mu-type>" and now expect a closing parenthesis.

component_eof: LPAREN LBRACKET JMP FOLD LPAREN Z_IDENTIFIER 
##
## Ends in an error in state: 97.
##
## fold(small_value) -> FOLD LPAREN . mu_type RPAREN small_value [ SEMICOLON RPAREN RBRACKET RANGLE LBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## FOLD LPAREN 
##

Parsing a folded value "fold <mu type> <value>", we have parsed "fold ("
and now expect a type of the form "mu a . tau".

component_eof: LPAREN LBRACKET JMP FOLD MU A_IDENTIFIER DOT A_IDENTIFIER UNPACK 
##
## Ends in an error in state: 121.
##
## fold(small_value) -> FOLD mu_type . small_value [ SEMICOLON RPAREN RBRACKET RANGLE LBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## FOLD mu_type 
##

Parsing a folded value "fold <mu type> <value>", we have parsed
"fold <mu-type>" and now expect an assembly value, for example
a register "r1".

component_eof: LPAREN LBRACKET JMP FOLD Z_IDENTIFIER 
##
## Ends in an error in state: 96.
##
## fold(small_value) -> FOLD . mu_type small_value [ SEMICOLON RPAREN RBRACKET RANGLE LBRACE COMMA ]
## fold(small_value) -> FOLD . LPAREN mu_type RPAREN small_value [ SEMICOLON RPAREN RBRACKET RANGLE LBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## FOLD 
##

Parsing a folded value "fold <mu type> <value>", we have parsed the
"fold" keyword and now expect a recursive type of the form
"mu <variable>. <type>", for example "mu a . int".

component_eof: LPAREN LBRACKET JMP LPAREN UNPACK 
##
## Ends in an error in state: 94.
##
## simple_small_value -> LPAREN . small_value RPAREN [ SEMICOLON RPAREN RBRACKET RANGLE LBRACKET LBRACE COMMA ]
## simple_small_value -> LPAREN . RPAREN [ SEMICOLON RPAREN RBRACKET RANGLE LBRACKET LBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## LPAREN 
##

Parsing a TAL value, we parsed an opening parenthesis "(" and expect
a value, or a closing parenthesis ")" to form the unit value "()".

component_eof: LPAREN LBRACKET JMP LPAREN Z_IDENTIFIER SEMICOLON 
##
## Ends in an error in state: 123.
##
## simple_small_value -> LPAREN small_value . RPAREN [ SEMICOLON RPAREN RBRACKET RANGLE LBRACKET LBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## LPAREN small_value 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 103, spurious reduction of production small_value -> simple_small_value 
##

Parsing a TAL value, we parsed "( <value>" so far and expect a closing
parenthesis ")".

component_eof: LPAREN LBRACKET JMP MINUS Z_IDENTIFIER 
##
## Ends in an error in state: 92.
##
## small_value -> MINUS . nat [ SEMICOLON RPAREN RBRACKET RANGLE LBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## MINUS 
##

Parsing a TAL value, we parsed a unary negation "-" and expect an
integer to form a negative integer literal such as "-3".

component_eof: LPAREN LBRACKET JMP PACK LANGLE UNIT COMMA UNPACK 
##
## Ends in an error in state: 90.
##
## pack(small_value) -> PACK LANGLE value_type COMMA . small_value RANGLE AS existential_type [ SEMICOLON RPAREN RBRACKET RANGLE LBRACKET LBRACE COMMA ]
## pack(small_value) -> PACK LANGLE value_type COMMA . small_value RANGLE AS LPAREN existential_type RPAREN [ SEMICOLON RPAREN RBRACKET RANGLE LBRACKET LBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## PACK LANGLE value_type COMMA 
##

Parsing a packed value
"pack < <type>, <value> > as (exists <var> . <type>)", we parsed
"pack < <type>," so far and expect a value. A complete example of
packed value is "pack <int, 1> as (exists a . a)".

component_eof: LPAREN LBRACKET JMP PACK LANGLE UNIT COMMA Z_IDENTIFIER RANGLE AS LPAREN EXISTS A_IDENTIFIER DOT A_IDENTIFIER Z_IDENTIFIER 
##
## Ends in an error in state: 129.
##
## pack(small_value) -> PACK LANGLE value_type COMMA small_value RANGLE AS LPAREN existential_type . RPAREN [ SEMICOLON RPAREN RBRACKET RANGLE LBRACKET LBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## PACK LANGLE value_type COMMA small_value RANGLE AS LPAREN existential_type 
##

Parsing a packed value
"pack < <type>, <value> > as (exists <var> . <type>)", we parsed
"pack < <type>, <value> > as (exists <var> . <type>" so far and expect
a closing parentehsis.

component_eof: LPAREN LBRACKET JMP PACK LANGLE UNIT COMMA Z_IDENTIFIER RANGLE AS LPAREN Z_IDENTIFIER 
##
## Ends in an error in state: 128.
##
## pack(small_value) -> PACK LANGLE value_type COMMA small_value RANGLE AS LPAREN . existential_type RPAREN [ SEMICOLON RPAREN RBRACKET RANGLE LBRACKET LBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## PACK LANGLE value_type COMMA small_value RANGLE AS LPAREN 
##

Parsing a packed value
"pack < <type>, <value> > as (exists <var> . <type>)", we parsed
"pack < <type>, <value> > as (" so far and expect
an existential type, for example "exists a . <int, a>".

component_eof: LPAREN LBRACKET JMP PACK LANGLE UNIT COMMA Z_IDENTIFIER RANGLE AS Z_IDENTIFIER 
##
## Ends in an error in state: 127.
##
## pack(small_value) -> PACK LANGLE value_type COMMA small_value RANGLE AS . existential_type [ SEMICOLON RPAREN RBRACKET RANGLE LBRACKET LBRACE COMMA ]
## pack(small_value) -> PACK LANGLE value_type COMMA small_value RANGLE AS . LPAREN existential_type RPAREN [ SEMICOLON RPAREN RBRACKET RANGLE LBRACKET LBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## PACK LANGLE value_type COMMA small_value RANGLE AS 
##

Parsing a packed value
"pack < <type>, <value> > as (exists <var> . <type>)", we parsed
"pack < <type>, <value> > as" so far and expect
an existential type, for example "(exists a . <int, a>)".

component_eof: LPAREN LBRACKET JMP PACK LANGLE UNIT COMMA Z_IDENTIFIER RANGLE Z_IDENTIFIER 
##
## Ends in an error in state: 126.
##
## pack(small_value) -> PACK LANGLE value_type COMMA small_value RANGLE . AS existential_type [ SEMICOLON RPAREN RBRACKET RANGLE LBRACKET LBRACE COMMA ]
## pack(small_value) -> PACK LANGLE value_type COMMA small_value RANGLE . AS LPAREN existential_type RPAREN [ SEMICOLON RPAREN RBRACKET RANGLE LBRACKET LBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## PACK LANGLE value_type COMMA small_value RANGLE 
##

Parsing a packed value
"pack < <type>, <value> > as (exists <var> . <type>)", we parsed
"pack < <type>, <value> >" so far and expect the "as" keyword followed
by an existential type, for example "as (exists a . <int, a>)".

component_eof: LPAREN LBRACKET JMP PACK LANGLE UNIT COMMA Z_IDENTIFIER SEMICOLON 
##
## Ends in an error in state: 125.
##
## pack(small_value) -> PACK LANGLE value_type COMMA small_value . RANGLE AS existential_type [ SEMICOLON RPAREN RBRACKET RANGLE LBRACKET LBRACE COMMA ]
## pack(small_value) -> PACK LANGLE value_type COMMA small_value . RANGLE AS LPAREN existential_type RPAREN [ SEMICOLON RPAREN RBRACKET RANGLE LBRACKET LBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## PACK LANGLE value_type COMMA small_value 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 103, spurious reduction of production small_value -> simple_small_value 
##

Parsing a packed value
"pack < <type>, <value> > as (exists <var> . <type>)", we parsed
"pack < <type>, <value>" so far and expect a closing angle bracket
">".

component_eof: LPAREN LBRACKET JMP PACK LANGLE UNIT Z_IDENTIFIER 
##
## Ends in an error in state: 89.
##
## pack(small_value) -> PACK LANGLE value_type . COMMA small_value RANGLE AS existential_type [ SEMICOLON RPAREN RBRACKET RANGLE LBRACKET LBRACE COMMA ]
## pack(small_value) -> PACK LANGLE value_type . COMMA small_value RANGLE AS LPAREN existential_type RPAREN [ SEMICOLON RPAREN RBRACKET RANGLE LBRACKET LBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## PACK LANGLE value_type 
##

Parsing a packed value
"pack < <type>, <value> > as (exists <var> . <type>)", we parsed
"pack < <type>" so far and expect a comma "," followed by the value to
pack.

component_eof: LPAREN LBRACKET JMP PACK LANGLE Z_IDENTIFIER 
##
## Ends in an error in state: 14.
##
## pack(small_value) -> PACK LANGLE . value_type COMMA small_value RANGLE AS existential_type [ SEMICOLON RPAREN RBRACKET RANGLE LBRACKET LBRACE COMMA ]
## pack(small_value) -> PACK LANGLE . value_type COMMA small_value RANGLE AS LPAREN existential_type RPAREN [ SEMICOLON RPAREN RBRACKET RANGLE LBRACKET LBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## PACK LANGLE 
##

Parsing a packed value
"pack < <type>, <value> > as (exists <var> . <type>)", we parsed
"pack < " so far and expect the type of the value to pack.

component_eof: LPAREN LBRACKET JMP PACK Z_IDENTIFIER 
##
## Ends in an error in state: 13.
##
## pack(small_value) -> PACK . LANGLE value_type COMMA small_value RANGLE AS existential_type [ SEMICOLON RPAREN RBRACKET RANGLE LBRACKET LBRACE COMMA ]
## pack(small_value) -> PACK . LANGLE value_type COMMA small_value RANGLE AS LPAREN existential_type RPAREN [ SEMICOLON RPAREN RBRACKET RANGLE LBRACKET LBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## PACK 
##

Parsing a packed value
"pack < <type>, <value> > as (exists <var> . <type>)", we parsed
the "pack" keyword so far and expect the type and value to pack,
for example "< int, 1 >".

component_eof: LPAREN LBRACKET JMP UNPACK 
##
## Ends in an error in state: 188.
##
## final_instruction -> JMP . small_value [ SEMICOLON RBRACKET ]
##
## The known suffix of the stack is as follows:
## JMP 
##

Parsing a "jmp <value>" instruction, we parsed the "jmp" keyword and
expect a TAL value.

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER LBRACKET END LBRACE UNIT SEMICOLON UNPACK 
##
## Ends in an error in state: 58.
##
## return_marker -> END LBRACE value_type SEMICOLON . stack_typing RBRACE [ Z_IDENTIFIER SEMICOLON RPAREN REGISTER RBRACKET RBRACE RANGLE PACK OTHER_IDENTIFIER MINUS LPAREN LBRACKET LBRACE INTEGER FOLD E_IDENTIFIER DOUBLECOLON DOT COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## END LBRACE value_type SEMICOLON 
##

Parsing the "end { <type>; <stack typing> }" return marker,
we parsed "end { <type>;" so far and expect a stack typing,
for example "int :: z" or "*".

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER LBRACKET END LBRACE UNIT SEMICOLON Z_IDENTIFIER Z_IDENTIFIER 
##
## Ends in an error in state: 59.
##
## return_marker -> END LBRACE value_type SEMICOLON stack_typing . RBRACE [ Z_IDENTIFIER SEMICOLON RPAREN REGISTER RBRACKET RBRACE RANGLE PACK OTHER_IDENTIFIER MINUS LPAREN LBRACKET LBRACE INTEGER FOLD E_IDENTIFIER DOUBLECOLON DOT COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## END LBRACE value_type SEMICOLON stack_typing 
##

Parsing the "end { <type>; <stack typing> }" return marker, we parsed
"end { <type>; <stack typing>" so far and expect a closing brace "}".

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER LBRACKET END LBRACE UNIT Z_IDENTIFIER 
##
## Ends in an error in state: 57.
##
## return_marker -> END LBRACE value_type . SEMICOLON stack_typing RBRACE [ Z_IDENTIFIER SEMICOLON RPAREN REGISTER RBRACKET RBRACE RANGLE PACK OTHER_IDENTIFIER MINUS LPAREN LBRACKET LBRACE INTEGER FOLD E_IDENTIFIER DOUBLECOLON DOT COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## END LBRACE value_type 
##

Parsing the "end { <type>; <stack typing> }" return marker, we parsed
"end { <type>" so far and expect the symbol ";" followed by a stack
typing.

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER LBRACKET END LBRACE Z_IDENTIFIER 
##
## Ends in an error in state: 56.
##
## return_marker -> END LBRACE . value_type SEMICOLON stack_typing RBRACE [ Z_IDENTIFIER SEMICOLON RPAREN REGISTER RBRACKET RBRACE RANGLE PACK OTHER_IDENTIFIER MINUS LPAREN LBRACKET LBRACE INTEGER FOLD E_IDENTIFIER DOUBLECOLON DOT COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## END LBRACE 
##

Parsing the "end { <type>; <stack typing> }" return marker, we parsed
"end {" so far and expect a return type.

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER LBRACKET END Z_IDENTIFIER 
##
## Ends in an error in state: 55.
##
## return_marker -> END . LBRACE value_type SEMICOLON stack_typing RBRACE [ Z_IDENTIFIER SEMICOLON RPAREN REGISTER RBRACKET RBRACE RANGLE PACK OTHER_IDENTIFIER MINUS LPAREN LBRACKET LBRACE INTEGER FOLD E_IDENTIFIER DOUBLECOLON DOT COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## END 
##

Parsing the "end { <type>; <stack typing> }" return marker, we parsed
the "end" keyword so far and expect the return type and stack typing,
for example "{ int; unit :: * }".

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER LBRACKET UNIT Z_IDENTIFIER 
##
## Ends in an error in state: 105.
##
## list(__anonymous_0) -> value_type . DOUBLECOLON list(__anonymous_0) [ Z_IDENTIFIER TIMES ]
## type_instantiation -> value_type . [ RBRACKET COMMA ]
##
## The known suffix of the stack is as follows:
## value_type 
##

We expect a TAL value type.

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER LBRACKET UNPACK 
##
## Ends in an error in state: 104.
##
## app(simple_small_value) -> simple_small_value LBRACKET . loption(separated_nonempty_list(COMMA,type_instantiation)) RBRACKET [ SEMICOLON RPAREN RBRACKET RANGLE LBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## simple_small_value LBRACKET 
##

Parsing an instantiation "<value> [ <type>, <type>... ]", we parsed
"<value> [" and expect a TAL instantiation type, that is either
a value type, a stack typing or a return marker.

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER LBRACKET Z_IDENTIFIER COMMA UNPACK 
##
## Ends in an error in state: 107.
##
## separated_nonempty_list(COMMA,type_instantiation) -> type_instantiation COMMA . separated_nonempty_list(COMMA,type_instantiation) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## type_instantiation COMMA 
##

Parsing an instantiation "<value> [ <type>, <type>... ]", we parsed
a comma "," and expect a TAL instantiation type, that is either
a value type, a stack typing or a return marker.

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER LBRACKET Z_IDENTIFIER Z_IDENTIFIER 
##
## Ends in an error in state: 106.
##
## separated_nonempty_list(COMMA,type_instantiation) -> type_instantiation . [ RBRACKET ]
## separated_nonempty_list(COMMA,type_instantiation) -> type_instantiation . COMMA separated_nonempty_list(COMMA,type_instantiation) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## type_instantiation 
##

Parsing an instantiation "<value> [ <type>, <type>... ]", we parsed an
instantiation type and expect a comma "," or a closing bracket "]".

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER RBRACKET COMMA LBRACKET RBRACKET RPAREN Z_IDENTIFIER 
##
## Ends in an error in state: 384.
##
## component_eof -> component . EOF [ # ]
##
## The known suffix of the stack is as follows:
## component 
##

We parsed a complete component and expect nothing else.

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER RBRACKET COMMA LBRACKET RBRACKET Z_IDENTIFIER 
##
## Ends in an error in state: 381.
##
## component -> LPAREN instruction_sequence COMMA heap_fragment . RPAREN [ Z_IDENTIFIER TIMES RPAREN RBRACE RANGLE PLUS PI OTHER_IDENTIFIER MINUS LPAREN LANGLE INTEGER FT E_IDENTIFIER EOF COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## LPAREN instruction_sequence COMMA heap_fragment 
##

Parsing a TAL component "( [<instructions>], [<heap fragment>] )", we
parsed "( [<instructions>], [<heap fragment>]" so far and expect
a closing parenthesis ")".

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER RBRACKET COMMA LBRACKET UNPACK 
##
## Ends in an error in state: 348.
##
## heap_fragment -> LBRACKET . simple_heap_fragment RBRACKET [ RPAREN ]
##
## The known suffix of the stack is as follows:
## LBRACKET 
##

We parsed an opening parenthesis "[" so far and expect a heap fragment,
for example "[]" or "[l1 -> box <1>, l2 -> ref <2, 3>]".

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER RBRACKET COMMA LBRACKET Z_IDENTIFIER ARROW REF CODE LBRACKET RBRACKET LBRACE SEMICOLON UNPACK 
##
## Ends in an error in state: 370.
##
## heap_value -> mutability_annotation CODE type_env LBRACE simple_register_typing SEMICOLON . stack_typing RBRACE return_marker DOT instruction_sequence [ RBRACKET COMMA ]
##
## The known suffix of the stack is as follows:
## mutability_annotation CODE type_env LBRACE simple_register_typing SEMICOLON 
##

Parsing a code block value
"box code [<type env>] { <register typing>; <stack typing> } <return marker>. [<instructions>]",
we parsed "box code [<type env>] { <register typing>;" so far and
expect a stack typing, for example "int :: z" or "unit :: *".

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER RBRACKET COMMA LBRACKET Z_IDENTIFIER ARROW REF CODE LBRACKET RBRACKET LBRACE SEMICOLON Z_IDENTIFIER RBRACE REGISTER DOT Z_IDENTIFIER 
##
## Ends in an error in state: 374.
##
## heap_value -> mutability_annotation CODE type_env LBRACE simple_register_typing SEMICOLON stack_typing RBRACE return_marker DOT . instruction_sequence [ RBRACKET COMMA ]
##
## The known suffix of the stack is as follows:
## mutability_annotation CODE type_env LBRACE simple_register_typing SEMICOLON stack_typing RBRACE return_marker DOT 
##

Parsing a code block value
"box code [<type env>] { <register typing>; <stack typing> } <return marker>. [<instructions>]",
we parsed
"box code [<type env>] { <register typing>; <stack typing> } <return marker>."
so far and expect a bracketed, semicolon-separated instruction
sequence.

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER RBRACKET COMMA LBRACKET Z_IDENTIFIER ARROW REF CODE LBRACKET RBRACKET LBRACE SEMICOLON Z_IDENTIFIER RBRACE REGISTER Z_IDENTIFIER 
##
## Ends in an error in state: 373.
##
## heap_value -> mutability_annotation CODE type_env LBRACE simple_register_typing SEMICOLON stack_typing RBRACE return_marker . DOT instruction_sequence [ RBRACKET COMMA ]
##
## The known suffix of the stack is as follows:
## mutability_annotation CODE type_env LBRACE simple_register_typing SEMICOLON stack_typing RBRACE return_marker 
##

Parsing a code block value
"box code [<type env>] { <register typing>; <stack typing> } <return marker>. [<instructions>]",
we parsed
"box code [<type env>] { <register typing>; <stack typing> }." so far
and expect a dot followed by a bracketed, semicolon-separated
instruction sequence.

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER RBRACKET COMMA LBRACKET Z_IDENTIFIER ARROW REF CODE LBRACKET RBRACKET LBRACE SEMICOLON Z_IDENTIFIER RBRACE Z_IDENTIFIER 
##
## Ends in an error in state: 372.
##
## heap_value -> mutability_annotation CODE type_env LBRACE simple_register_typing SEMICOLON stack_typing RBRACE . return_marker DOT instruction_sequence [ RBRACKET COMMA ]
##
## The known suffix of the stack is as follows:
## mutability_annotation CODE type_env LBRACE simple_register_typing SEMICOLON stack_typing RBRACE 
##

Parsing a code block value
"box code [<type env>] { <register typing>; <stack typing> } <return marker>. [<instructions>]",
we parsed
"box code [<type env>] { <register typing>; <stack typing> }" so far
and expect a return marker, that is either:
- a register "r1",
- a stack position "3",
- a return variable "e",
- the end marker "end {<type>; <stack-typing>}" or
- the cross-language marker "out".

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER RBRACKET COMMA LBRACKET Z_IDENTIFIER ARROW REF CODE LBRACKET RBRACKET LBRACE SEMICOLON Z_IDENTIFIER Z_IDENTIFIER 
##
## Ends in an error in state: 371.
##
## heap_value -> mutability_annotation CODE type_env LBRACE simple_register_typing SEMICOLON stack_typing . RBRACE return_marker DOT instruction_sequence [ RBRACKET COMMA ]
##
## The known suffix of the stack is as follows:
## mutability_annotation CODE type_env LBRACE simple_register_typing SEMICOLON stack_typing 
##

Parsing a code block value
"box code [<type env>] { <register typing>; <stack typing> } <return marker>. [<instructions>]",
we parsed
"box code [<type env>] { <register typing>; <stack typing>" so far
and expect a closing brace "}" followed by a return marker.

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER RBRACKET COMMA LBRACKET Z_IDENTIFIER ARROW REF CODE LBRACKET RBRACKET LBRACE Z_IDENTIFIER 
##
## Ends in an error in state: 368.
##
## heap_value -> mutability_annotation CODE type_env LBRACE . simple_register_typing SEMICOLON stack_typing RBRACE return_marker DOT instruction_sequence [ RBRACKET COMMA ]
##
## The known suffix of the stack is as follows:
## mutability_annotation CODE type_env LBRACE 
##

Parsing a code block value
"box code [<type env>] { <register typing>; <stack typing> } <return marker>. [<instructions>]",
we parsed
"box code [<type env>] {" and expect a register typing, for example "r1 : int, r2 : unit".

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER RBRACKET COMMA LBRACKET Z_IDENTIFIER ARROW REF CODE LBRACKET RBRACKET Z_IDENTIFIER 
##
## Ends in an error in state: 367.
##
## heap_value -> mutability_annotation CODE type_env . LBRACE simple_register_typing SEMICOLON stack_typing RBRACE return_marker DOT instruction_sequence [ RBRACKET COMMA ]
##
## The known suffix of the stack is as follows:
## mutability_annotation CODE type_env 
##

Parsing a code block value
"box code [<type env>] { <register typing>; <stack typing> } <return marker>. [<instructions>]",
we parsed "box code [<type env>]" so far and expect a register and
stack typing, for example "{ r1 : int, r2 : unit; int :: z }".

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER RBRACKET COMMA LBRACKET Z_IDENTIFIER ARROW REF CODE Z_IDENTIFIER 
##
## Ends in an error in state: 366.
##
## heap_value -> mutability_annotation CODE . type_env LBRACE simple_register_typing SEMICOLON stack_typing RBRACE return_marker DOT instruction_sequence [ RBRACKET COMMA ]
##
## The known suffix of the stack is as follows:
## mutability_annotation CODE 
##

Parsing a code block value
"box code [<type env>] { <register typing>; <stack typing> } <return marker>. [<instructions>]",
we parsed "box code [" so far and expect a typing environment, for
example "a, e2, z']".

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER RBRACKET COMMA LBRACKET Z_IDENTIFIER ARROW REF LANGLE RANGLE COMMA UNPACK 
##
## Ends in an error in state: 379.
##
## separated_nonempty_list(COMMA,binding(location,heap_value)) -> binding(location,heap_value) COMMA . separated_nonempty_list(COMMA,binding(location,heap_value)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## binding(location,heap_value) COMMA 
##

Parsing a heap fragment "[ <location> -> <heap value>, ... ]",
we parsed a comma and expect more "<location> -> <heap value>" pairs.

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER RBRACKET COMMA LBRACKET Z_IDENTIFIER ARROW REF LANGLE RANGLE Z_IDENTIFIER 
##
## Ends in an error in state: 378.
##
## separated_nonempty_list(COMMA,binding(location,heap_value)) -> binding(location,heap_value) . [ RBRACKET ]
## separated_nonempty_list(COMMA,binding(location,heap_value)) -> binding(location,heap_value) . COMMA separated_nonempty_list(COMMA,binding(location,heap_value)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## binding(location,heap_value) 
##

Parsing a heap fragment "[ <location> -> <heap value>, ... ]", we
parsed a "<location> -> <heap value>" pair and expect a comma "," or
a closing bracket "]".

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER RBRACKET COMMA LBRACKET Z_IDENTIFIER ARROW REF LANGLE UNPACK 
##
## Ends in an error in state: 358.
##
## tuple(word_value) -> LANGLE . loption(separated_nonempty_list(COMMA,word_value)) RANGLE [ RBRACKET COMMA ]
##
## The known suffix of the stack is as follows:
## LANGLE 
##

Parsing a tuple value "< <value>, <value>... >", we parsed an opening
angle bracket "<" and expect a TAL value.

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER RBRACKET COMMA LBRACKET Z_IDENTIFIER ARROW REF LANGLE Z_IDENTIFIER COMMA UNPACK 
##
## Ends in an error in state: 360.
##
## separated_nonempty_list(COMMA,word_value) -> word_value COMMA . separated_nonempty_list(COMMA,word_value) [ RANGLE ]
##
## The known suffix of the stack is as follows:
## word_value COMMA 
##

Parsing a tuple value "< <value>, <value>... >", we parsed a comma ","
and expect a TAL value.

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER RBRACKET COMMA LBRACKET Z_IDENTIFIER ARROW REF LANGLE Z_IDENTIFIER SEMICOLON 
##
## Ends in an error in state: 359.
##
## separated_nonempty_list(COMMA,word_value) -> word_value . [ RANGLE ]
## separated_nonempty_list(COMMA,word_value) -> word_value . COMMA separated_nonempty_list(COMMA,word_value) [ RANGLE ]
##
## The known suffix of the stack is as follows:
## word_value 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 103, spurious reduction of production small_value -> simple_small_value 
## In state 361, spurious reduction of production word_value -> small_value 
##

Parsing a tuple value "< <value>, <value>... >", we parsed a value and
expect a comma "," or a closing angle bracket ">".

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER RBRACKET COMMA LBRACKET Z_IDENTIFIER ARROW REF Z_IDENTIFIER 
##
## Ends in an error in state: 357.
##
## heap_value -> mutability_annotation . CODE type_env LBRACE simple_register_typing SEMICOLON stack_typing RBRACE return_marker DOT instruction_sequence [ RBRACKET COMMA ]
## heap_value -> mutability_annotation . tuple(word_value) [ RBRACKET COMMA ]
##
## The known suffix of the stack is as follows:
## mutability_annotation 
##

Parsing a heap value "<mutability annotation> <value>", we parsed
a mutability annotation ("box" or "ref") and expect a tuple value
"< <value>, <vlaue>... >" or code block value
"code [<type env>] { <register typing>; <stack typing > } <return marker> . [<instructions>]".

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER RBRACKET COMMA LBRACKET Z_IDENTIFIER ARROW Z_IDENTIFIER 
##
## Ends in an error in state: 354.
##
## binding(location,heap_value) -> location ARROW . heap_value [ RBRACKET COMMA ]
##
## The known suffix of the stack is as follows:
## location ARROW 
##

Parsing a heap binding
"<location> -> <mutability annotation> <value>", we parsed
"<location> ->" so far and expect a mutability annotation ("box" or
"ref") followed by a heap value.

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER RBRACKET COMMA LBRACKET Z_IDENTIFIER Z_IDENTIFIER 
##
## Ends in an error in state: 353.
##
## binding(location,heap_value) -> location . ARROW heap_value [ RBRACKET COMMA ]
##
## The known suffix of the stack is as follows:
## location 
##

Parsing a heap binding
"<location> -> <mutability annotation> <value>", we parsed a location
so far, and expect an arrow symbol "->".

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER RBRACKET COMMA Z_IDENTIFIER 
##
## Ends in an error in state: 347.
##
## component -> LPAREN instruction_sequence COMMA . heap_fragment RPAREN [ Z_IDENTIFIER TIMES RPAREN RBRACE RANGLE PLUS PI OTHER_IDENTIFIER MINUS LPAREN LANGLE INTEGER FT E_IDENTIFIER EOF COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## LPAREN instruction_sequence COMMA 
##

Parsing a component "( [<instructions>], [<heap fragment>] )", we
parsed "( [<instructions>]," so far and expect a heap fragment,
for example "[]" or "[l1 -> box <1>, l2 -> ref <2, 3>]".

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER RBRACKET Z_IDENTIFIER 
##
## Ends in an error in state: 346.
##
## component -> LPAREN instruction_sequence . COMMA heap_fragment RPAREN [ Z_IDENTIFIER TIMES RPAREN RBRACE RANGLE PLUS PI OTHER_IDENTIFIER MINUS LPAREN LANGLE INTEGER FT E_IDENTIFIER EOF COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## LPAREN instruction_sequence 
##

Parsing a component "( [<instructions>], [<heap fragment>] )", we
parsed "( [<instructions>]" so far and expect a comma "," followed by
a heap fragment.

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER RPAREN 
##
## Ends in an error in state: 335.
##
## simple_instruction_sequence -> final_instruction . option(SEMICOLON) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## final_instruction 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 103, spurious reduction of production small_value -> simple_small_value 
## In state 189, spurious reduction of production final_instruction -> JMP small_value 
##

Parsing an instruction sequence "[ <instructions> ]", we parsed
a final instruction and expect a closing bracket "]".

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER SEMICOLON Z_IDENTIFIER 
##
## Ends in an error in state: 344.
##
## instruction_sequence -> LBRACKET simple_instruction_sequence . RBRACKET [ RBRACKET COMMA ]
##
## The known suffix of the stack is as follows:
## LBRACKET simple_instruction_sequence 
##

Parsing an instruction sequence "[ <instructions> ]", we parsed
a final instruction and expect a closing bracket "]".

component_eof: LPAREN LBRACKET JMP Z_IDENTIFIER Z_IDENTIFIER 
##
## Ends in an error in state: 103.
##
## app(simple_small_value) -> simple_small_value . LBRACKET loption(separated_nonempty_list(COMMA,type_instantiation)) RBRACKET [ SEMICOLON RPAREN RBRACKET RANGLE LBRACE COMMA ]
## small_value -> simple_small_value . [ SEMICOLON RPAREN RBRACKET RANGLE LBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## simple_small_value 
##

We expect a valid TAL value.

component_eof: LPAREN LBRACKET LD REGISTER COMMA REGISTER Z_IDENTIFIER 
##
## Ends in an error in state: 186.
##
## single_instruction -> LD register COMMA register . bracketpos [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## LD register COMMA register 
##

Parsing a tuple-load instruction
"ld <register>, <register> [ <pos> ];", we parsed
"ld <register>, <register>" so far and expect a position within
a tuple, for example "[2]".

component_eof: LPAREN LBRACKET LD REGISTER COMMA Z_IDENTIFIER 
##
## Ends in an error in state: 185.
##
## single_instruction -> LD register COMMA . register bracketpos [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## LD register COMMA 
##

Parsing a tuple-load instruction
"ld <register>, <register> [ <pos> ]", we parsed "ld <register>," so
far and expect a register holding a tuple.

component_eof: LPAREN LBRACKET LD REGISTER Z_IDENTIFIER 
##
## Ends in an error in state: 184.
##
## single_instruction -> LD register . COMMA register bracketpos [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## LD register 
##

Parsing a tuple-load instruction
"ld <register>, <register> [ <pos> ];", we parsed "ld <register>" so
far and expect a comma "," followed by a register and bracketed index.

component_eof: LPAREN LBRACKET LD Z_IDENTIFIER 
##
## Ends in an error in state: 183.
##
## single_instruction -> LD . register COMMA register bracketpos [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## LD 
##

Parsing a tuple-load instruction
"ld <register>, <register> [ <pos> ];", we parsed the "ld" keyword and
expect the destination register.

component_eof: LPAREN LBRACKET MV REGISTER COMMA UNPACK 
##
## Ends in an error in state: 180.
##
## single_instruction -> MV register COMMA . small_value [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## MV register COMMA 
##

Parsing a move instruction "mv <register>, <value>", we parsed
"mv <register>," so far and expect the value to move.

component_eof: LPAREN LBRACKET MV REGISTER Z_IDENTIFIER 
##
## Ends in an error in state: 179.
##
## single_instruction -> MV register . COMMA small_value [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## MV register 
##

Parsing a move instruction "mv <register>, <value>;", we parsed
"mv <register>" so far and expect a comma followed by a value.

component_eof: LPAREN LBRACKET MV Z_IDENTIFIER 
##
## Ends in an error in state: 178.
##
## single_instruction -> MV . register COMMA small_value [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## MV 
##

Parsing a move instruction "mv <register>, <value>;", we parsed
the "mv" keyword so far the destination register.

component_eof: LPAREN LBRACKET PROTECT Z_IDENTIFIER 
##
## Ends in an error in state: 168.
##
## single_instruction -> PROTECT . stack_prefix COMMA stack_typing_variable [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## PROTECT 
##

Parsing the protect instruction
"protect <stack prefix>, <stack variable>;", we parsed the "protect"
keyword and expect a stack prefix, for example "int :: a ::" or "::".

component_eof: LPAREN LBRACKET RALLOC REGISTER COMMA Z_IDENTIFIER 
##
## Ends in an error in state: 166.
##
## single_instruction -> RALLOC register COMMA . nat [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## RALLOC register COMMA 
##

Parsing the tuple-allocation instruction "ralloc <register>, <nat>",
we parsed "ralloc <register>," so far and expect the size of the
mutable tuple to allocate.

component_eof: LPAREN LBRACKET RALLOC REGISTER Z_IDENTIFIER 
##
## Ends in an error in state: 165.
##
## single_instruction -> RALLOC register . COMMA nat [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## RALLOC register 
##

Parsing the tuple-allocation instruction "ralloc <register>, <nat>",
we parsed "ralloc <register>" so far and expect a comma "," followed
by a size.

component_eof: LPAREN LBRACKET RALLOC Z_IDENTIFIER 
##
## Ends in an error in state: 164.
##
## single_instruction -> RALLOC . register COMMA nat [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## RALLOC 
##

Parsing the tuple-allocation instruction "ralloc <register>, <nat>",
we parsed the "ralloc" keyword and expect a destination register.

component_eof: LPAREN LBRACKET RET REGISTER LBRACE REGISTER Z_IDENTIFIER 
##
## Ends in an error in state: 161.
##
## bracereg -> LBRACE register . RBRACE [ SEMICOLON RBRACKET ]
##
## The known suffix of the stack is as follows:
## LBRACE register 
##

Parsing a result register "{ <register> }",
we parsed "{ <register>" so far and expect a closing brace "}".

component_eof: LPAREN LBRACKET RET REGISTER LBRACE Z_IDENTIFIER 
##
## Ends in an error in state: 160.
##
## bracereg -> LBRACE . register RBRACE [ SEMICOLON RBRACKET ]
##
## The known suffix of the stack is as follows:
## LBRACE 
##

Parsing a result register "{ <register> }", we parsed "{" so far
and expect a register, "r1", "r2"... "r7" or "ra".

component_eof: LPAREN LBRACKET RET REGISTER Z_IDENTIFIER 
##
## Ends in an error in state: 159.
##
## final_instruction -> RET register . bracereg [ SEMICOLON RBRACKET ]
##
## The known suffix of the stack is as follows:
## RET register 
##

Parsing a return instruction "ret <register> { <register> }", we
parsed "ret <register>" so far and expect a bracket result register
"{ <register> }".

component_eof: LPAREN LBRACKET RET Z_IDENTIFIER 
##
## Ends in an error in state: 158.
##
## final_instruction -> RET . register bracereg [ SEMICOLON RBRACKET ]
##
## The known suffix of the stack is as follows:
## RET 
##

Parsing a return instruction "ret <register> { <register> }", we
parsed the "ret" keyword and expect the return register.

component_eof: LPAREN LBRACKET SALLOC Z_IDENTIFIER 
##
## Ends in an error in state: 156.
##
## single_instruction -> SALLOC . nat [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## SALLOC 
##

Parsing a stack-allocation instruction "salloc <nat>;", we parsed the
"salloc" keyword and expect the allocation size, for example "3".

component_eof: LPAREN LBRACKET SFREE INTEGER SEMICOLON Z_IDENTIFIER 
##
## Ends in an error in state: 333.
##
## simple_instruction_sequence -> single_instruction SEMICOLON . simple_instruction_sequence [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## single_instruction SEMICOLON 
##

Parsing an instruction sequence, we parsed a non-final instruction and
a semicolon ";", and expect the rest of the sequence.

component_eof: LPAREN LBRACKET SFREE INTEGER Z_IDENTIFIER 
##
## Ends in an error in state: 332.
##
## simple_instruction_sequence -> single_instruction . SEMICOLON simple_instruction_sequence [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## single_instruction 
##

Parsing an instruction sequence, we parsed a non-final instruction,
and expect a semicolon ";" followed by the rest of the sequence.

component_eof: LPAREN LBRACKET SFREE Z_IDENTIFIER 
##
## Ends in an error in state: 154.
##
## single_instruction -> SFREE . nat [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## SFREE 
##

Parsing a stack deallocation instruction "sfree <nat>;", we parsed the
"sfree" keyword and expect the deallocation size.

component_eof: LPAREN LBRACKET SLD REGISTER COMMA Z_IDENTIFIER 
##
## Ends in an error in state: 152.
##
## single_instruction -> SLD register COMMA . nat [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## SLD register COMMA 
##

Parsing a stack-load instruction "sld <register>, <pos>;", we parsed
"sld <register>," so far and expect the stack position to load, for
example "3".

component_eof: LPAREN LBRACKET SLD REGISTER Z_IDENTIFIER 
##
## Ends in an error in state: 151.
##
## single_instruction -> SLD register . COMMA nat [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## SLD register 
##

Parsing a stack-load instruction "sld <register>, <pos>;", we parsed
"sld <register>," so far and expect a comma followed by a stack
position.

component_eof: LPAREN LBRACKET SLD Z_IDENTIFIER 
##
## Ends in an error in state: 150.
##
## single_instruction -> SLD . register COMMA nat [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## SLD 
##

Parsing a stack-load instruction "sld <register>, <pos>;", we parsed
the "sld" keyword and expect the destination register.

component_eof: LPAREN LBRACKET SST INTEGER COMMA Z_IDENTIFIER 
##
## Ends in an error in state: 148.
##
## single_instruction -> SST nat COMMA . register [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## SST nat COMMA 
##

Parsing a stack-store instruction "sst <pos>, <register>;", we parsed
"sst <pos>," so far and expect the register containing the value
to write.

component_eof: LPAREN LBRACKET SST INTEGER Z_IDENTIFIER 
##
## Ends in an error in state: 147.
##
## single_instruction -> SST nat . COMMA register [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## SST nat 
##

Parsing a stack-store instruction "sst <pos>, <register>;", we parsed
"sst <pos>" so far and expect a comma followed by a register.

component_eof: LPAREN LBRACKET SST Z_IDENTIFIER 
##
## Ends in an error in state: 146.
##
## single_instruction -> SST . nat COMMA register [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## SST 
##

Parsing a stack-store instruction "sst <pos>, <register>;", we parsed
the "sst" keyword so far and expect the stack position to write to,
for example "3".

component_eof: LPAREN LBRACKET ST REGISTER LBRACKET INTEGER RBRACKET COMMA Z_IDENTIFIER 
##
## Ends in an error in state: 144.
##
## single_instruction -> ST register bracketpos COMMA . register [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## ST register bracketpos COMMA 
##

Parsing a tuple-store instruction
"st <register>[ <pos> ], <register>;", we parsed
"st <register>[ <pos> ]," so far and expect the register containing
the value to store.

component_eof: LPAREN LBRACKET ST REGISTER LBRACKET INTEGER RBRACKET Z_IDENTIFIER 
##
## Ends in an error in state: 143.
##
## single_instruction -> ST register bracketpos . COMMA register [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## ST register bracketpos 
##

Parsing a tuple-store instruction
"st <register>[ <pos> ], <register>;", we parsed
"st <register>[ <pos> ]" so far and expect a comma "," followed by
a register.

component_eof: LPAREN LBRACKET ST REGISTER LBRACKET INTEGER Z_IDENTIFIER 
##
## Ends in an error in state: 141.
##
## bracketpos -> LBRACKET nat . RBRACKET [ SEMICOLON COMMA ]
##
## The known suffix of the stack is as follows:
## LBRACKET nat 
##

Parsing a tuple position "[ <pos> ]", we parsed "[ <pos>" so far and
expect a closing bracket "]".

component_eof: LPAREN LBRACKET ST REGISTER LBRACKET Z_IDENTIFIER 
##
## Ends in an error in state: 140.
##
## bracketpos -> LBRACKET . nat RBRACKET [ SEMICOLON COMMA ]
##
## The known suffix of the stack is as follows:
## LBRACKET 
##

Parsing a tuple position "[ <pos> ]", we parsed "[" so far and expect
an integer literal, for example "3".

component_eof: LPAREN LBRACKET ST REGISTER Z_IDENTIFIER 
##
## Ends in an error in state: 139.
##
## single_instruction -> ST register . bracketpos COMMA register [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## ST register 
##

Parsing a tuple-store instruction
"st <register>[ <pos> ], <register>;", we parsed
"st <register>" so far and expect a tuple position, for example "[3]".

component_eof: LPAREN LBRACKET ST Z_IDENTIFIER 
##
## Ends in an error in state: 138.
##
## single_instruction -> ST . register bracketpos COMMA register [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## ST 
##

Parsing a tuple-store instruction
"st <register>[ <pos> ], <register>;", we parsed
the "st" keyword and expect a tuple register and a position within the tuple,
for example "r1[3]".

component_eof: LPAREN LBRACKET SUB REGISTER COMMA REGISTER COMMA UNPACK 
##
## Ends in an error in state: 342.
##
## single_instruction -> aop register COMMA register COMMA . small_value [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## aop register COMMA register COMMA 
##

Parsing an arithmetic operation instruction
"<op> <register>, <register>, <value>;", we parsed
"<op> <register>, <register>," so far and expect a value operand.

component_eof: LPAREN LBRACKET SUB REGISTER COMMA REGISTER Z_IDENTIFIER 
##
## Ends in an error in state: 341.
##
## single_instruction -> aop register COMMA register . COMMA small_value [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## aop register COMMA register 
##

Parsing an arithmetic operation instruction
"<op> <register>, <register>, <value>;", we parsed
"<op> <register>, <register>" so far and expect a comma "," followed
by a value.

component_eof: LPAREN LBRACKET SUB REGISTER COMMA Z_IDENTIFIER 
##
## Ends in an error in state: 340.
##
## single_instruction -> aop register COMMA . register COMMA small_value [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## aop register COMMA 
##

Parsing an arithmetic operation instruction
"<op> <register>, <register>, <value>;", we parsed "<op> <register>,"
so far and expect a register operand, "r1", "r2"... "r7" or "ra".

component_eof: LPAREN LBRACKET SUB REGISTER Z_IDENTIFIER 
##
## Ends in an error in state: 339.
##
## single_instruction -> aop register . COMMA register COMMA small_value [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## aop register 
##

Parsing an arithmetic operation instruction
"<op> <register>, <register>, <value>;", we parsed "<op> <register>"
so far and expect a comma "," followed by a register operand.

component_eof: LPAREN LBRACKET SUB Z_IDENTIFIER 
##
## Ends in an error in state: 338.
##
## single_instruction -> aop . register COMMA register COMMA small_value [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## aop 
##

Parsing an arithmetic operation instruction
"<op> <register>, <register>, <value>;", we parsed an operation
keyword and expect a destination register, "r1", "r2"... "r7" or "ra".

component_eof: LPAREN LBRACKET UNFOLD REGISTER COMMA UNPACK 
##
## Ends in an error in state: 135.
##
## single_instruction -> UNFOLD register COMMA . small_value [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## UNFOLD register COMMA 
##

Parsing an unfold instruction "unfold <register>, <value>;",
we parsed "unfold <register>," so far and expect the value to unfold.

component_eof: LPAREN LBRACKET UNFOLD REGISTER Z_IDENTIFIER 
##
## Ends in an error in state: 134.
##
## single_instruction -> UNFOLD register . COMMA small_value [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## UNFOLD register 
##

Parsing an unfold instruction "unfold <register>, <value>;", we parsed
"unfold <register>" so far and expect a comma followed by a value.

component_eof: LPAREN LBRACKET UNFOLD Z_IDENTIFIER 
##
## Ends in an error in state: 133.
##
## single_instruction -> UNFOLD . register COMMA small_value [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## UNFOLD 
##

Parsing an unfold instruction "unfold <register>, <value>;", we parsed
the "unfold" keyword and expect a destination register.

component_eof: LPAREN LBRACKET UNPACK LANGLE A_IDENTIFIER COMMA REGISTER RANGLE COMMA UNPACK 
##
## Ends in an error in state: 11.
##
## single_instruction -> UNPACK LANGLE type_variable COMMA register RANGLE COMMA . small_value [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## UNPACK LANGLE type_variable COMMA register RANGLE COMMA 
##

Parsing an unpack instruction
"unpack < <type variable>, <register> >, <value>;", we parsed
"unpack < <type variable>, <register> >," so far and expect the value
to unpack.

component_eof: LPAREN LBRACKET UNPACK LANGLE A_IDENTIFIER COMMA REGISTER RANGLE Z_IDENTIFIER 
##
## Ends in an error in state: 10.
##
## single_instruction -> UNPACK LANGLE type_variable COMMA register RANGLE . COMMA small_value [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## UNPACK LANGLE type_variable COMMA register RANGLE 
##

Parsing an unpack instruction
"unpack < <type variable>, <register> >, <value>;", we parsed
"unpack < <type variable>, <register> >" so far and expect a comma ","
followed by a value.

component_eof: LPAREN LBRACKET UNPACK LANGLE A_IDENTIFIER COMMA REGISTER Z_IDENTIFIER 
##
## Ends in an error in state: 9.
##
## single_instruction -> UNPACK LANGLE type_variable COMMA register . RANGLE COMMA small_value [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## UNPACK LANGLE type_variable COMMA register 
##

Parsing an unpack instruction
"unpack < <type variable>, <register> >, <value>;", we parsed
"unpack < <type variable>, <register>" so far and expect a closing
angle bracket ">".

component_eof: LPAREN LBRACKET UNPACK LANGLE A_IDENTIFIER COMMA Z_IDENTIFIER 
##
## Ends in an error in state: 7.
##
## single_instruction -> UNPACK LANGLE type_variable COMMA . register RANGLE COMMA small_value [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## UNPACK LANGLE type_variable COMMA 
##

Parsing an unpack instruction
"unpack < <type variable>, <register> >, <value>;", we parsed
"unpack < <type variable>," so far and expect a destination register,
"r1", "r2"... "r7" or "ra".

component_eof: LPAREN LBRACKET UNPACK LANGLE A_IDENTIFIER Z_IDENTIFIER 
##
## Ends in an error in state: 6.
##
## single_instruction -> UNPACK LANGLE type_variable . COMMA register RANGLE COMMA small_value [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## UNPACK LANGLE type_variable 
##

Parsing an unpack instruction
"unpack < <type variable>, <register> >, <value>;", we parsed
"unpack < <type variable>" so far and expect a comma followed by
a register.

component_eof: LPAREN LBRACKET UNPACK LANGLE Z_IDENTIFIER 
##
## Ends in an error in state: 4.
##
## single_instruction -> UNPACK LANGLE . type_variable COMMA register RANGLE COMMA small_value [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## UNPACK LANGLE 
##

Parsing an unpack instruction
"unpack < <type variable>, <register> >, <value>;", we parsed
"unpack < " so far and a expect type variable to introduce.

component_eof: LPAREN LBRACKET UNPACK Z_IDENTIFIER 
##
## Ends in an error in state: 3.
##
## single_instruction -> UNPACK . LANGLE type_variable COMMA register RANGLE COMMA small_value [ SEMICOLON ]
##
## The known suffix of the stack is as follows:
## UNPACK 
##

Parsing an unpack instruction
"unpack < <type variable>, <register> >, <value>;", we parsed the
"unpack" keyword and expect a type variable and destination register,
for example "<a2, r3>".

component_eof: LPAREN LBRACKET Z_IDENTIFIER 
##
## Ends in an error in state: 2.
##
## instruction_sequence -> LBRACKET . simple_instruction_sequence RBRACKET [ RBRACKET COMMA ]
##
## The known suffix of the stack is as follows:
## LBRACKET 
##

Parsing an instruction sequence "[ <instructions> ]", we expect
a non-final instruction followed by a semicolon or a final
instruction.

component_eof: LPAREN Z_IDENTIFIER 
##
## Ends in an error in state: 1.
##
## component -> LPAREN . instruction_sequence COMMA heap_fragment RPAREN [ Z_IDENTIFIER TIMES RPAREN RBRACE RANGLE PLUS PI OTHER_IDENTIFIER MINUS LPAREN LANGLE INTEGER FT E_IDENTIFIER EOF COMMA A_IDENTIFIER ]
##
## The known suffix of the stack is as follows:
## LPAREN 
##

Parsing a component "( [<instructions>], [<heap fragment>] )", we
parsed the opening parenthesis "(" and expect a bracketed instruction
sequence.

component_eof: Z_IDENTIFIER 
##
## Ends in an error in state: 0.
##
## component_eof' -> . component_eof [ # ]
##
## The known suffix of the stack is as follows:
## 
##

We expect a TAL component "( [<instructions>], [<heap fragment>] )".

